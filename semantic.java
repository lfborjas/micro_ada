
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon Nov 30 00:51:19 CST 2009
//----------------------------------------------------

import java_cup.runtime.*;
import java.util.Stack;
import java.util.ArrayList;
import AdaSemantic.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Mon Nov 30 00:51:19 CST 2009
  */
public class semantic extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public semantic() {super();}

  /** Constructor which sets the default scanner. */
  public semantic(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public semantic(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\374\000\002\002\004\000\002\006\002\000\002\006" +
    "\003\000\002\002\003\000\002\003\002\000\002\004\002" +
    "\000\002\005\002\000\002\010\003\000\002\010\003\000" +
    "\002\007\003\000\002\007\003\000\002\011\003\000\002" +
    "\013\003\000\002\013\005\000\002\014\003\000\002\014" +
    "\005\000\002\015\003\000\002\015\003\000\002\015\003" +
    "\000\002\015\003\000\002\015\003\000\002\016\010\000" +
    "\002\016\010\000\002\017\002\000\002\017\004\000\002" +
    "\020\010\000\002\020\010\000\002\012\005\000\002\012" +
    "\005\000\002\021\010\000\002\021\003\000\002\022\002" +
    "\000\002\022\003\000\002\023\003\000\002\024\007\000" +
    "\002\025\003\000\002\025\003\000\002\025\003\000\002" +
    "\026\004\000\002\026\004\000\002\026\004\000\002\026" +
    "\004\000\002\027\004\000\002\030\005\000\002\031\003" +
    "\000\002\031\003\000\002\032\005\000\002\033\002\000" +
    "\002\033\003\000\002\034\005\000\002\035\004\000\002" +
    "\035\004\000\002\035\003\000\002\160\002\000\002\161" +
    "\002\000\002\036\010\000\002\162\002\000\002\037\005" +
    "\000\002\163\002\000\002\037\005\000\002\040\002\000" +
    "\002\040\004\000\002\041\002\000\002\041\003\000\002" +
    "\164\002\000\002\042\005\000\002\042\003\000\002\043" +
    "\005\000\002\044\003\000\002\044\005\000\002\045\006" +
    "\000\002\045\006\000\002\046\011\000\002\047\002\000" +
    "\002\047\007\000\002\050\003\000\002\050\003\000\002" +
    "\050\004\000\002\050\003\000\002\051\003\000\002\051" +
    "\005\000\002\052\006\000\002\053\003\000\002\054\002" +
    "\000\002\054\004\000\002\055\003\000\002\055\003\000" +
    "\002\055\004\000\002\056\003\000\002\056\003\000\002" +
    "\056\003\000\002\056\003\000\002\057\005\000\002\057" +
    "\005\000\002\057\005\000\002\060\003\000\002\060\003" +
    "\000\002\060\003\000\002\060\003\000\002\060\003\000" +
    "\002\061\005\000\002\061\007\000\002\062\005\000\002" +
    "\062\005\000\002\063\003\000\002\063\005\000\002\064" +
    "\003\000\002\064\003\000\002\064\003\000\002\064\003" +
    "\000\002\064\003\000\002\064\003\000\002\065\006\000" +
    "\002\065\006\000\002\066\006\000\002\066\006\000\002" +
    "\067\005\000\002\067\005\000\002\070\006\000\002\070" +
    "\006\000\002\071\006\000\002\071\006\000\002\072\003" +
    "\000\002\072\005\000\002\072\005\000\002\072\005\000" +
    "\002\073\003\000\002\073\004\000\002\074\003\000\002" +
    "\074\004\000\002\075\003\000\002\075\005\000\002\076" +
    "\003\000\002\076\005\000\002\077\003\000\002\077\005" +
    "\000\002\100\003\000\002\100\003\000\002\100\003\000" +
    "\002\100\003\000\002\100\003\000\002\100\005\000\002" +
    "\101\003\000\002\101\003\000\002\101\003\000\002\101" +
    "\003\000\002\101\003\000\002\101\003\000\002\102\003" +
    "\000\002\102\003\000\002\102\003\000\002\103\003\000" +
    "\002\103\003\000\002\103\003\000\002\103\003\000\002" +
    "\104\003\000\002\104\003\000\002\104\003\000\002\104" +
    "\003\000\002\105\007\000\002\105\005\000\002\106\004" +
    "\000\002\107\003\000\002\107\004\000\002\110\004\000" +
    "\002\110\004\000\002\110\003\000\002\111\002\000\002" +
    "\111\004\000\002\112\003\000\002\112\003\000\002\112" +
    "\003\000\002\112\003\000\002\112\003\000\002\112\003" +
    "\000\002\112\003\000\002\113\003\000\002\113\003\000" +
    "\002\113\003\000\002\114\005\000\002\115\004\000\002" +
    "\116\006\000\002\165\002\000\002\166\002\000\002\117" +
    "\021\000\002\120\002\000\002\120\012\000\002\121\002" +
    "\000\002\121\005\000\002\122\003\000\002\167\002\000" +
    "\002\123\010\000\002\123\011\000\002\170\002\000\002" +
    "\124\007\000\002\125\002\000\002\125\007\000\002\125" +
    "\010\000\002\125\005\000\002\171\002\000\002\126\010" +
    "\000\002\172\002\000\002\126\013\000\002\127\002\000" +
    "\002\127\004\000\002\130\006\000\002\131\002\000\002" +
    "\131\003\000\002\132\002\000\002\132\004\000\002\133" +
    "\004\000\002\133\005\000\002\134\005\000\002\135\004" +
    "\000\002\136\005\000\002\136\007\000\002\137\005\000" +
    "\002\137\006\000\002\137\010\000\002\140\003\000\002" +
    "\140\003\000\002\141\003\000\002\173\002\000\002\142" +
    "\006\000\002\143\002\000\002\143\003\000\002\144\003" +
    "\000\002\144\005\000\002\145\007\000\002\145\007\000" +
    "\002\146\002\000\002\146\003\000\002\146\003\000\002" +
    "\146\004\000\002\174\002\000\002\175\002\000\002\147" +
    "\014\000\002\150\002\000\002\150\003\000\002\151\004" +
    "\000\002\152\005\000\002\152\004\000\002\152\004\000" +
    "\002\152\004\000\002\153\005\000\002\154\003\000\002" +
    "\155\003\000\002\155\004\000\002\155\003\000\002\156" +
    "\003\000\002\156\003\000\002\157\004" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u01b8\000\010\003\010\036\014\061\006\001\002\000" +
    "\010\002\uff07\036\uff07\061\uff07\001\002\000\020\003\uffae" +
    "\016\uffae\036\uffae\061\uffae\075\uffae\102\uffae\152\uffae\001" +
    "\002\000\004\152\023\001\002\000\004\002\ufffe\001\002" +
    "\000\010\002\uff09\036\uff09\061\uff09\001\002\000\010\002" +
    "\uff0c\036\014\061\006\001\002\000\010\002\uff08\036\uff08" +
    "\061\uff08\001\002\000\004\002\333\001\002\000\006\152" +
    "\023\156\024\001\002\000\004\124\017\001\002\000\010" +
    "\002\uff0b\036\uff0b\061\uff0b\001\002\000\022\002\uff2c\003" +
    "\uff2c\016\uff2c\036\uff2c\061\uff2c\075\uff2c\102\uff2c\152\uff2c" +
    "\001\002\000\006\071\uff21\113\026\001\002\000\010\071" +
    "\uff26\113\uff26\124\uff26\001\002\000\010\071\uff25\113\uff25" +
    "\124\uff25\001\002\000\124\013\ufff6\024\ufff6\025\ufff6\042" +
    "\ufff6\043\ufff6\045\ufff6\046\ufff6\050\ufff6\053\ufff6\064\ufff6" +
    "\066\ufff6\071\ufff6\101\ufff6\105\ufff6\110\ufff6\111\ufff6\112" +
    "\ufff6\113\ufff6\114\ufff6\115\ufff6\116\ufff6\117\ufff6\120\ufff6" +
    "\121\ufff6\122\ufff6\123\ufff6\124\ufff6\125\ufff6\126\ufff6\127" +
    "\ufff6\130\ufff6\131\ufff6\132\ufff6\133\ufff6\134\ufff6\135\ufff6" +
    "\136\ufff6\137\ufff6\141\ufff6\150\ufff6\151\ufff6\001\002\000" +
    "\120\013\uff24\024\uff24\025\uff24\042\uff24\043\uff24\045\uff24" +
    "\046\uff24\050\uff24\053\uff24\064\uff24\066\uff24\071\uff24\101" +
    "\uff24\105\uff24\110\uff24\111\uff24\112\uff24\113\uff24\114\uff24" +
    "\115\uff24\116\uff24\117\uff24\120\uff24\121\uff24\122\uff24\124" +
    "\uff24\125\uff24\126\uff24\127\uff24\130\uff24\131\uff24\132\uff24" +
    "\133\uff24\134\uff24\135\uff24\136\uff24\137\uff24\150\uff24\151" +
    "\uff24\001\002\000\004\071\uff20\001\002\000\004\152\023" +
    "\001\002\000\004\071\030\001\002\000\020\143\034\144" +
    "\045\145\035\146\033\147\046\152\023\156\024\001\002" +
    "\000\032\013\uffdd\043\uffdd\045\uffdd\053\uffdd\101\uffdd\110" +
    "\uffdd\114\uffdd\121\uffdd\124\uffdd\137\uffdd\150\uffdd\151\uffdd" +
    "\001\002\000\024\024\053\025\050\043\uffde\064\144\113" +
    "\105\114\uffde\122\102\124\uffde\137\uffde\001\002\000\034" +
    "\013\ufffa\043\ufffa\045\ufffa\053\ufffa\064\ufffa\101\ufffa\110" +
    "\ufffa\114\ufffa\121\ufffa\124\ufffa\137\ufffa\150\ufffa\151\ufffa" +
    "\001\002\000\004\113\276\001\002\000\032\013\ufff8\043" +
    "\ufff8\045\ufff8\053\ufff8\101\ufff8\110\ufff8\114\ufff8\121\ufff8" +
    "\124\ufff8\137\ufff8\150\ufff8\151\ufff8\001\002\000\006\043" +
    "\300\124\uff2a\001\002\000\116\013\uffa8\024\uffa8\025\uffa8" +
    "\042\uffa8\043\uffa8\045\uffa8\046\uffa8\050\uffa8\053\uffa8\064" +
    "\uffa8\066\uffa8\101\uffa8\105\uffa8\110\uffa8\111\uffa8\112\uffa8" +
    "\113\uffa8\114\uffa8\115\uffa8\116\uffa8\117\uffa8\120\uffa8\121" +
    "\uffa8\122\uffa8\124\uffa8\125\uffa8\126\uffa8\127\uffa8\130\uffa8" +
    "\131\uffa8\132\uffa8\133\uffa8\134\uffa8\135\uffa8\136\uffa8\137" +
    "\uffa8\150\uffa8\151\uffa8\001\002\000\116\013\uffa7\024\uffa7" +
    "\025\uffa7\042\uffa7\043\uffa7\045\uffa7\046\uffa7\050\uffa7\053" +
    "\uffa7\064\uffa7\066\uffa7\101\uffa7\105\uffa7\110\uffa7\111\uffa7" +
    "\112\uffa7\113\uffa7\114\uffa7\115\uffa7\116\uffa7\117\uffa7\120" +
    "\uffa7\121\uffa7\122\uffa7\124\uffa7\125\uffa7\126\uffa7\127\uffa7" +
    "\130\uffa7\131\uffa7\132\uffa7\133\uffa7\134\uffa7\135\uffa7\136" +
    "\uffa7\137\uffa7\150\uffa7\151\uffa7\001\002\000\032\013\uffdc" +
    "\043\uffdc\045\uffdc\053\uffdc\101\uffdc\110\uffdc\114\uffdc\121" +
    "\uffdc\124\uffdc\137\uffdc\150\uffdc\151\uffdc\001\002\000\116" +
    "\013\uffa9\024\uffa9\025\uffa9\042\uffa9\043\uffa9\045\uffa9\046" +
    "\uffa9\050\uffa9\053\uffa9\064\uffa9\066\uffa9\101\uffa9\105\uffa9" +
    "\110\uffa9\111\uffa9\112\uffa9\113\uffa9\114\uffa9\115\uffa9\116" +
    "\uffa9\117\uffa9\120\uffa9\121\uffa9\122\uffa9\124\uffa9\125\uffa9" +
    "\126\uffa9\127\uffa9\130\uffa9\131\uffa9\132\uffa9\133\uffa9\134" +
    "\uffa9\135\uffa9\136\uffa9\137\uffa9\150\uffa9\151\uffa9\001\002" +
    "\000\116\013\uffa6\024\uffa6\025\uffa6\042\uffa6\043\uffa6\045" +
    "\uffa6\046\uffa6\050\uffa6\053\uffa6\064\uffa6\066\uffa6\101\uffa6" +
    "\105\uffa6\110\uffa6\111\uffa6\112\uffa6\113\uffa6\114\uffa6\115" +
    "\uffa6\116\uffa6\117\uffa6\120\uffa6\121\uffa6\122\uffa6\124\uffa6" +
    "\125\uffa6\126\uffa6\127\uffa6\130\uffa6\131\uffa6\132\uffa6\133" +
    "\uffa6\134\uffa6\135\uffa6\136\uffa6\137\uffa6\150\uffa6\151\uffa6" +
    "\001\002\000\034\013\ufff7\043\ufff7\045\ufff7\053\ufff7\064" +
    "\144\101\ufff7\110\ufff7\114\ufff7\121\ufff7\124\ufff7\137\ufff7" +
    "\150\ufff7\151\ufff7\001\002\000\004\113\276\001\002\000" +
    "\040\013\ufff9\024\053\025\050\043\ufff9\045\ufff9\053\ufff9" +
    "\064\ufff9\101\ufff9\110\ufff9\114\ufff9\121\ufff9\124\ufff9\137" +
    "\ufff9\150\ufff9\151\ufff9\001\002\000\032\013\uffd8\043\uffd8" +
    "\045\uffd8\053\uffd8\101\uffd8\110\uffd8\114\uffd8\121\uffd8\124" +
    "\uffd8\137\uffd8\150\uffd8\151\uffd8\001\002\000\040\005\065" +
    "\047\074\050\056\051\100\113\055\117\054\120\067\143" +
    "\034\144\045\152\023\153\073\154\071\155\076\156\024" +
    "\157\057\001\002\000\032\013\uffd5\043\uffd5\045\uffd5\053" +
    "\uffd5\101\uffd5\110\uffd5\114\uffd5\121\uffd5\124\uffd5\137\uffd5" +
    "\150\uffd5\151\uffd5\001\002\000\032\013\uffd4\043\uffd4\045" +
    "\uffd4\053\uffd4\101\uffd4\110\uffd4\114\uffd4\121\uffd4\124\uffd4" +
    "\137\uffd4\150\uffd4\151\uffd4\001\002\000\040\005\065\047" +
    "\074\050\056\051\100\113\055\117\054\120\067\143\034" +
    "\144\045\152\023\153\073\154\071\155\076\156\024\157" +
    "\057\001\002\000\030\047\uff6a\051\uff6a\113\uff6a\143\uff6a" +
    "\144\uff6a\152\uff6a\153\uff6a\154\uff6a\155\uff6a\156\uff6a\157" +
    "\uff6a\001\002\000\042\005\065\047\074\050\056\051\100" +
    "\054\222\113\055\117\054\120\067\143\034\144\045\152" +
    "\023\153\073\154\071\155\076\156\024\157\057\001\002" +
    "\000\030\047\uff68\051\uff68\113\uff68\143\uff68\144\uff68\152" +
    "\uff68\153\uff68\154\uff68\155\uff68\156\uff68\157\uff68\001\002" +
    "\000\102\013\uff9f\042\uff9f\043\uff9f\045\uff9f\046\uff9f\050" +
    "\uff9f\053\uff9f\064\uff9f\066\uff9f\101\uff9f\110\uff9f\111\uff9f" +
    "\114\uff9f\115\uff9f\116\uff9f\117\uff9f\120\uff9f\121\uff9f\124" +
    "\uff9f\125\uff9f\126\uff9f\127\uff9f\130\uff9f\131\uff9f\132\uff9f" +
    "\133\uff9f\134\uff9f\135\uff9f\136\uff9f\137\uff9f\150\uff9f\151" +
    "\uff9f\001\002\000\102\013\uff76\042\uff76\043\uff76\045\uff76" +
    "\046\uff76\050\uff76\053\uff76\064\uff76\066\uff76\101\uff76\110" +
    "\uff76\111\uff76\114\uff76\115\uff76\116\uff76\117\uff76\120\uff76" +
    "\121\uff76\124\uff76\125\uff76\126\uff76\127\uff76\130\uff76\131" +
    "\uff76\132\uff76\133\uff76\134\uff76\135\uff76\136\uff76\137\uff76" +
    "\150\uff76\151\uff76\001\002\000\102\013\uff78\042\uff78\043" +
    "\uff78\045\uff78\046\uff78\050\uff78\053\uff78\064\uff78\066\uff78" +
    "\101\uff78\110\uff78\111\uff78\114\uff78\115\uff78\116\uff78\117" +
    "\uff78\120\uff78\121\uff78\124\uff78\125\uff78\126\uff78\127\uff78" +
    "\130\uff78\131\uff78\132\uff78\133\uff78\134\uff78\135\uff78\136" +
    "\uff78\137\uff78\150\uff78\151\uff78\001\002\000\100\013\uff7d" +
    "\042\uff7d\043\uff7d\045\uff7d\046\uff7d\050\uff7d\053\uff7d\064" +
    "\uff7d\066\uff7d\101\uff7d\110\uff7d\111\uff7d\114\uff7d\115\uff7d" +
    "\116\uff7d\117\uff7d\120\uff7d\121\uff7d\124\uff7d\125\uff7d\126" +
    "\uff7d\127\uff7d\130\uff7d\131\uff7d\132\uff7d\133\uff7d\134\uff7d" +
    "\135\uff7d\137\uff7d\150\uff7d\151\uff7d\001\002\000\100\013" +
    "\uff7f\042\uff7f\043\uff7f\045\uff7f\046\256\050\uff7f\053\uff7f" +
    "\064\uff7f\066\260\101\uff7f\110\uff7f\111\uff7f\114\uff7f\115" +
    "\262\116\261\117\uff7f\120\uff7f\121\uff7f\124\uff7f\125\uff7f" +
    "\126\uff7f\127\uff7f\130\uff7f\131\uff7f\132\uff7f\133\uff7f\134" +
    "\uff7f\135\uff7f\137\uff7f\150\uff7f\151\uff7f\001\002\000\034" +
    "\013\uffd2\043\uffd2\045\uffd2\053\uffd2\064\144\101\uffd2\110" +
    "\uffd2\114\uffd2\121\uffd2\124\uffd2\137\uffd2\150\uffd2\151\uffd2" +
    "\001\002\000\030\047\uff67\051\uff67\113\uff67\143\uff67\144" +
    "\uff67\152\uff67\153\uff67\154\uff67\155\uff67\156\uff67\157\uff67" +
    "\001\002\000\102\013\uff7b\042\uff7b\043\uff7b\045\uff7b\046" +
    "\uff7b\050\uff7b\053\uff7b\064\uff7b\066\uff7b\101\uff7b\110\uff7b" +
    "\111\uff7b\114\uff7b\115\uff7b\116\uff7b\117\uff7b\120\uff7b\121" +
    "\uff7b\124\uff7b\125\uff7b\126\uff7b\127\uff7b\130\uff7b\131\uff7b" +
    "\132\uff7b\133\uff7b\134\uff7b\135\uff7b\136\265\137\uff7b\150" +
    "\uff7b\151\uff7b\001\002\000\030\047\uff69\051\uff69\113\uff69" +
    "\143\uff69\144\uff69\152\uff69\153\uff69\154\uff69\155\uff69\156" +
    "\uff69\157\uff69\001\002\000\070\013\uff81\042\uff81\043\uff81" +
    "\045\uff81\050\uff81\053\uff81\064\uff81\101\uff81\110\uff81\111" +
    "\254\114\uff81\117\251\120\252\121\uff81\124\uff81\125\uff81" +
    "\126\uff81\127\uff81\130\uff81\131\uff81\132\uff81\133\uff81\134" +
    "\uff81\135\uff81\137\uff81\150\uff81\151\uff81\001\002\000\102" +
    "\013\uffa1\042\uffa1\043\uffa1\045\uffa1\046\uffa1\050\uffa1\053" +
    "\uffa1\064\uffa1\066\uffa1\101\uffa1\110\uffa1\111\uffa1\114\uffa1" +
    "\115\uffa1\116\uffa1\117\uffa1\120\uffa1\121\uffa1\124\uffa1\125" +
    "\uffa1\126\uffa1\127\uffa1\130\uffa1\131\uffa1\132\uffa1\133\uffa1" +
    "\134\uffa1\135\uffa1\136\uffa1\137\uffa1\150\uffa1\151\uffa1\001" +
    "\002\000\102\013\uff79\042\uff79\043\uff79\045\uff79\046\uff79" +
    "\050\uff79\053\uff79\064\uff79\066\uff79\101\uff79\110\uff79\111" +
    "\uff79\114\uff79\115\uff79\116\uff79\117\uff79\120\uff79\121\uff79" +
    "\124\uff79\125\uff79\126\uff79\127\uff79\130\uff79\131\uff79\132" +
    "\uff79\133\uff79\134\uff79\135\uff79\136\uff79\137\uff79\150\uff79" +
    "\151\uff79\001\002\000\102\013\uffa2\042\uffa2\043\uffa2\045" +
    "\uffa2\046\uffa2\050\uffa2\053\uffa2\064\uffa2\066\uffa2\101\uffa2" +
    "\110\uffa2\111\uffa2\114\uffa2\115\uffa2\116\uffa2\117\uffa2\120" +
    "\uffa2\121\uffa2\124\uffa2\125\uffa2\126\uffa2\127\uffa2\130\uffa2" +
    "\131\uffa2\132\uffa2\133\uffa2\134\uffa2\135\uffa2\136\uffa2\137" +
    "\uffa2\150\uffa2\151\uffa2\001\002\000\012\143\034\144\045" +
    "\152\023\156\024\001\002\000\102\013\uff75\042\uff75\043" +
    "\uff75\045\uff75\046\uff75\050\uff75\053\uff75\064\uff75\066\uff75" +
    "\101\uff75\110\uff75\111\uff75\114\uff75\115\uff75\116\uff75\117" +
    "\uff75\120\uff75\121\uff75\124\uff75\125\uff75\126\uff75\127\uff75" +
    "\130\uff75\131\uff75\132\uff75\133\uff75\134\uff75\135\uff75\136" +
    "\uff75\137\uff75\150\uff75\151\uff75\001\002\000\102\013\uffa0" +
    "\042\uffa0\043\uffa0\045\uffa0\046\uffa0\050\uffa0\053\uffa0\064" +
    "\uffa0\066\uffa0\101\uffa0\110\uffa0\111\uffa0\114\uffa0\115\uffa0" +
    "\116\uffa0\117\uffa0\120\uffa0\121\uffa0\124\uffa0\125\uffa0\126" +
    "\uffa0\127\uffa0\130\uffa0\131\uffa0\132\uffa0\133\uffa0\134\uffa0" +
    "\135\uffa0\136\uffa0\137\uffa0\150\uffa0\151\uffa0\001\002\000" +
    "\030\047\074\051\100\113\055\143\034\144\045\152\023" +
    "\153\073\154\071\155\076\156\024\157\057\001\002\000" +
    "\102\013\uff9e\042\uff9e\043\uff9e\045\uff9e\046\uff9e\050\uff9e" +
    "\053\uff9e\064\uff9e\066\uff9e\101\uff9e\110\uff9e\111\uff9e\114" +
    "\uff9e\115\uff9e\116\uff9e\117\uff9e\120\uff9e\121\uff9e\124\uff9e" +
    "\125\uff9e\126\uff9e\127\uff9e\130\uff9e\131\uff9e\132\uff9e\133" +
    "\uff9e\134\uff9e\135\uff9e\136\uff9e\137\uff9e\150\uff9e\151\uff9e" +
    "\001\002\000\110\013\uff77\042\uff77\043\uff77\045\uff77\046" +
    "\uff77\050\uff77\053\uff77\064\uff77\066\uff77\101\uff77\110\uff77" +
    "\111\uff77\112\104\113\105\114\uff77\115\uff77\116\uff77\117" +
    "\uff77\120\uff77\121\uff77\122\102\124\uff77\125\uff77\126\uff77" +
    "\127\uff77\130\uff77\131\uff77\132\uff77\133\uff77\134\uff77\135" +
    "\uff77\136\uff77\137\uff77\150\uff77\151\uff77\001\002\000\010" +
    "\012\245\152\023\156\024\001\002\000\116\013\uff10\024" +
    "\uff10\025\uff10\042\uff10\043\uff10\045\uff10\046\uff10\050\uff10" +
    "\053\uff10\064\uff10\066\uff10\101\uff10\105\uff10\110\uff10\111" +
    "\uff10\112\uff10\113\uff10\114\uff10\115\uff10\116\uff10\117\uff10" +
    "\120\uff10\121\uff10\122\uff10\124\uff10\125\uff10\126\uff10\127" +
    "\uff10\130\uff10\131\uff10\132\uff10\133\uff10\134\uff10\135\uff10" +
    "\136\uff10\137\uff10\150\uff10\151\uff10\001\002\000\004\113" +
    "\212\001\002\000\042\005\065\047\074\050\056\051\100" +
    "\113\055\114\115\117\054\120\067\143\034\144\045\152" +
    "\023\153\073\154\071\155\076\156\024\157\057\001\002" +
    "\000\016\045\uff93\101\uff93\114\uff93\121\uff93\124\uff93\150" +
    "\206\001\002\000\016\045\uff95\053\203\101\uff95\114\uff95" +
    "\121\uff95\124\uff95\001\002\000\070\013\uffa9\042\uffa9\046" +
    "\uffa9\050\uffa9\053\uffa9\066\uffa9\110\uffa9\111\uffa9\112\uffa9" +
    "\113\uffa9\114\uffa9\115\uffa9\116\uffa9\117\uffa9\120\uffa9\121" +
    "\uffa9\122\uffa9\125\uffa9\126\uffa9\127\uffa9\130\uffa9\131\uffa9" +
    "\132\uffa9\134\201\136\uffa9\150\uffa9\151\uffa9\001\002\000" +
    "\026\013\164\045\uff97\053\167\101\uff97\110\166\114\uff97" +
    "\121\uff97\124\uff97\150\165\151\163\001\002\000\006\114" +
    "\ufff3\121\ufff3\001\002\000\006\114\161\121\160\001\002" +
    "\000\016\045\uff92\101\uff92\114\uff92\121\uff92\124\uff92\151" +
    "\155\001\002\000\116\013\uff11\024\uff11\025\uff11\042\uff11" +
    "\043\uff11\045\uff11\046\uff11\050\uff11\053\uff11\064\uff11\066" +
    "\uff11\101\uff11\105\uff11\110\uff11\111\uff11\112\uff11\113\uff11" +
    "\114\uff11\115\uff11\116\uff11\117\uff11\120\uff11\121\uff11\122" +
    "\uff11\124\uff11\125\uff11\126\uff11\127\uff11\130\uff11\131\uff11" +
    "\132\uff11\133\uff11\134\uff11\135\uff11\136\uff11\137\uff11\150" +
    "\uff11\151\uff11\001\002\000\016\013\152\045\uff96\101\uff96" +
    "\114\uff96\121\uff96\124\uff96\001\002\000\016\045\uff94\101" +
    "\uff94\110\150\114\uff94\121\uff94\124\uff94\001\002\000\006" +
    "\114\ufff5\121\ufff5\001\002\000\046\013\uff87\042\123\045" +
    "\uff87\050\131\053\uff87\101\uff87\110\uff87\114\uff87\121\uff87" +
    "\124\uff87\125\127\126\132\127\125\130\130\131\122\132" +
    "\133\150\uff87\151\uff87\001\002\000\040\005\uff6f\047\uff6f" +
    "\050\uff6f\051\uff6f\113\uff6f\117\uff6f\120\uff6f\143\uff6f\144" +
    "\uff6f\152\uff6f\153\uff6f\154\uff6f\155\uff6f\156\uff6f\157\uff6f" +
    "\001\002\000\046\005\uff83\047\uff83\050\uff83\051\uff83\113" +
    "\uff83\117\uff83\120\uff83\143\uff83\144\uff83\145\uff83\146\uff83" +
    "\147\uff83\152\uff83\153\uff83\154\uff83\155\uff83\156\uff83\157" +
    "\uff83\001\002\000\040\005\065\047\074\050\056\051\100" +
    "\113\055\117\054\120\067\143\034\144\045\152\023\153" +
    "\073\154\071\155\076\156\024\157\057\001\002\000\040" +
    "\005\uff73\047\uff73\050\uff73\051\uff73\113\uff73\117\uff73\120" +
    "\uff73\143\uff73\144\uff73\152\uff73\153\uff73\154\uff73\155\uff73" +
    "\156\uff73\157\uff73\001\002\000\046\005\065\047\074\050" +
    "\056\051\100\113\055\117\054\120\067\143\034\144\045" +
    "\145\035\146\033\147\046\152\023\153\073\154\071\155" +
    "\076\156\024\157\057\001\002\000\040\005\uff70\047\uff70" +
    "\050\uff70\051\uff70\113\uff70\117\uff70\120\uff70\143\uff70\144" +
    "\uff70\152\uff70\153\uff70\154\uff70\155\uff70\156\uff70\157\uff70" +
    "\001\002\000\040\005\uff72\047\uff72\050\uff72\051\uff72\113" +
    "\uff72\117\uff72\120\uff72\143\uff72\144\uff72\152\uff72\153\uff72" +
    "\154\uff72\155\uff72\156\uff72\157\uff72\001\002\000\004\042" +
    "\134\001\002\000\040\005\uff71\047\uff71\050\uff71\051\uff71" +
    "\113\uff71\117\uff71\120\uff71\143\uff71\144\uff71\152\uff71\153" +
    "\uff71\154\uff71\155\uff71\156\uff71\157\uff71\001\002\000\040" +
    "\005\uff6e\047\uff6e\050\uff6e\051\uff6e\113\uff6e\117\uff6e\120" +
    "\uff6e\143\uff6e\144\uff6e\152\uff6e\153\uff6e\154\uff6e\155\uff6e" +
    "\156\uff6e\157\uff6e\001\002\000\046\005\uff82\047\uff82\050" +
    "\uff82\051\uff82\113\uff82\117\uff82\120\uff82\143\uff82\144\uff82" +
    "\145\uff82\146\uff82\147\uff82\152\uff82\153\uff82\154\uff82\155" +
    "\uff82\156\uff82\157\uff82\001\002\000\026\013\uff85\045\uff85" +
    "\053\uff85\101\uff85\110\uff85\114\uff85\121\uff85\124\uff85\150" +
    "\uff85\151\uff85\001\002\000\064\013\uffde\024\053\025\050" +
    "\045\uffde\046\uff77\053\uffde\064\144\066\uff77\101\uffde\110" +
    "\uffde\111\uff77\112\104\113\105\114\uffde\115\uff77\116\uff77" +
    "\117\uff77\120\uff77\121\uffde\122\102\124\uffde\135\uff77\136" +
    "\uff77\150\uffde\151\uffde\001\002\000\026\013\uff84\045\uff84" +
    "\053\uff84\101\uff84\110\uff84\114\uff84\121\uff84\124\uff84\150" +
    "\uff84\151\uff84\001\002\000\004\135\141\001\002\000\040" +
    "\005\065\047\074\050\056\051\100\113\055\117\054\120" +
    "\067\143\034\144\045\152\023\153\073\154\071\155\076" +
    "\156\024\157\057\001\002\000\036\013\uffd6\043\uffd6\045" +
    "\uffd6\053\uffd6\101\uffd6\110\uffd6\114\uffd6\121\uffd6\124\uffd6" +
    "\133\uffd6\134\uffd6\137\uffd6\150\uffd6\151\uffd6\001\002\000" +
    "\032\013\uffdb\043\uffdb\045\uffdb\053\uffdb\101\uffdb\110\uffdb" +
    "\114\uffdb\121\uffdb\124\uffdb\137\uffdb\150\uffdb\151\uffdb\001" +
    "\002\000\040\005\065\047\074\050\056\051\100\113\055" +
    "\117\054\120\067\143\034\144\045\152\023\153\073\154" +
    "\071\155\076\156\024\157\057\001\002\000\032\013\uffda" +
    "\043\uffda\045\uffda\053\uffda\101\uffda\110\uffda\114\uffda\121" +
    "\uffda\124\uffda\137\uffda\150\uffda\151\uffda\001\002\000\036" +
    "\013\uffd7\043\uffd7\045\uffd7\053\uffd7\101\uffd7\110\uffd7\114" +
    "\uffd7\121\uffd7\124\uffd7\133\uffd7\134\uffd7\137\uffd7\150\uffd7" +
    "\151\uffd7\001\002\000\026\013\uff86\045\uff86\053\uff86\101" +
    "\uff86\110\uff86\114\uff86\121\uff86\124\uff86\150\uff86\151\uff86" +
    "\001\002\000\040\005\065\047\074\050\056\051\100\113" +
    "\055\117\054\120\067\143\034\144\045\152\023\153\073" +
    "\154\071\155\076\156\024\157\057\001\002\000\016\045" +
    "\uff8c\101\uff8c\110\uff8c\114\uff8c\121\uff8c\124\uff8c\001\002" +
    "\000\040\005\ufffc\047\ufffc\050\ufffc\051\ufffc\113\ufffc\117" +
    "\ufffc\120\ufffc\143\ufffc\144\ufffc\152\ufffc\153\ufffc\154\ufffc" +
    "\155\ufffc\156\ufffc\157\ufffc\001\002\000\040\005\065\047" +
    "\074\050\056\051\100\113\055\117\054\120\067\143\034" +
    "\144\045\152\023\153\073\154\071\155\076\156\024\157" +
    "\057\001\002\000\016\013\uff90\045\uff90\101\uff90\114\uff90" +
    "\121\uff90\124\uff90\001\002\000\040\005\ufffc\047\ufffc\050" +
    "\ufffc\051\ufffc\113\ufffc\117\ufffc\120\ufffc\143\ufffc\144\ufffc" +
    "\152\ufffc\153\ufffc\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001" +
    "\002\000\040\005\065\047\074\050\056\051\100\113\055" +
    "\117\054\120\067\143\034\144\045\152\023\153\073\154" +
    "\071\155\076\156\024\157\057\001\002\000\016\045\uff88" +
    "\101\uff88\114\uff88\121\uff88\124\uff88\151\uff88\001\002\000" +
    "\040\005\065\047\074\050\056\051\100\113\055\117\054" +
    "\120\067\143\034\144\045\152\023\153\073\154\071\155" +
    "\076\156\024\157\057\001\002\000\116\013\uff0d\024\uff0d" +
    "\025\uff0d\042\uff0d\043\uff0d\045\uff0d\046\uff0d\050\uff0d\053" +
    "\uff0d\064\uff0d\066\uff0d\101\uff0d\105\uff0d\110\uff0d\111\uff0d" +
    "\112\uff0d\113\uff0d\114\uff0d\115\uff0d\116\uff0d\117\uff0d\120" +
    "\uff0d\121\uff0d\122\uff0d\124\uff0d\125\uff0d\126\uff0d\127\uff0d" +
    "\130\uff0d\131\uff0d\132\uff0d\133\uff0d\134\uff0d\135\uff0d\136" +
    "\uff0d\137\uff0d\150\uff0d\151\uff0d\001\002\000\006\114\ufff4" +
    "\121\ufff4\001\002\000\040\005\ufffc\047\ufffc\050\ufffc\051" +
    "\ufffc\113\ufffc\117\ufffc\120\ufffc\143\ufffc\144\ufffc\152\ufffc" +
    "\153\ufffc\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001\002\000" +
    "\040\005\ufffc\047\ufffc\050\ufffc\051\ufffc\113\ufffc\117\ufffc" +
    "\120\ufffc\143\ufffc\144\ufffc\152\ufffc\153\ufffc\154\ufffc\155" +
    "\ufffc\156\ufffc\157\ufffc\001\002\000\040\005\ufffc\047\ufffc" +
    "\050\ufffc\051\ufffc\113\ufffc\117\ufffc\120\ufffc\143\ufffc\144" +
    "\ufffc\152\ufffc\153\ufffc\154\ufffc\155\ufffc\156\ufffc\157\ufffc" +
    "\001\002\000\040\005\065\047\074\050\056\051\100\113" +
    "\055\117\054\120\067\143\034\144\045\152\023\153\073" +
    "\154\071\155\076\156\024\157\057\001\002\000\040\005" +
    "\ufffc\047\ufffc\050\ufffc\051\ufffc\113\ufffc\117\ufffc\120\ufffc" +
    "\143\ufffc\144\ufffc\152\ufffc\153\ufffc\154\ufffc\155\ufffc\156" +
    "\ufffc\157\ufffc\001\002\000\040\005\065\047\074\050\056" +
    "\051\100\113\055\117\054\120\067\143\034\144\045\152" +
    "\023\153\073\154\071\155\076\156\024\157\057\001\002" +
    "\000\016\045\uff8f\053\uff8f\101\uff8f\114\uff8f\121\uff8f\124" +
    "\uff8f\001\002\000\016\045\uff8d\101\uff8d\110\uff8d\114\uff8d" +
    "\121\uff8d\124\uff8d\001\002\000\040\005\065\047\074\050" +
    "\056\051\100\113\055\117\054\120\067\143\034\144\045" +
    "\152\023\153\073\154\071\155\076\156\024\157\057\001" +
    "\002\000\016\045\uff8b\101\uff8b\114\uff8b\121\uff8b\124\uff8b" +
    "\150\uff8b\001\002\000\040\005\065\047\074\050\056\051" +
    "\100\113\055\117\054\120\067\143\034\144\045\152\023" +
    "\153\073\154\071\155\076\156\024\157\057\001\002\000" +
    "\016\013\uff91\045\uff91\101\uff91\114\uff91\121\uff91\124\uff91" +
    "\001\002\000\040\005\065\047\074\050\056\051\100\113" +
    "\055\117\054\120\067\143\034\144\045\152\023\153\073" +
    "\154\071\155\076\156\024\157\057\001\002\000\016\045" +
    "\uff89\101\uff89\114\uff89\121\uff89\124\uff89\151\uff89\001\002" +
    "\000\040\005\065\047\074\050\056\051\100\113\055\117" +
    "\054\120\067\143\034\144\045\152\023\153\073\154\071" +
    "\155\076\156\024\157\057\001\002\000\006\114\ufff2\121" +
    "\ufff2\001\002\000\040\005\ufffc\047\ufffc\050\ufffc\051\ufffc" +
    "\113\ufffc\117\ufffc\120\ufffc\143\ufffc\144\ufffc\152\ufffc\153" +
    "\ufffc\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001\002\000\040" +
    "\005\065\047\074\050\056\051\100\113\055\117\054\120" +
    "\067\143\034\144\045\152\023\153\073\154\071\155\076" +
    "\156\024\157\057\001\002\000\016\045\uff8e\053\uff8e\101" +
    "\uff8e\114\uff8e\121\uff8e\124\uff8e\001\002\000\040\005\ufffc" +
    "\047\ufffc\050\ufffc\051\ufffc\113\ufffc\117\ufffc\120\ufffc\143" +
    "\ufffc\144\ufffc\152\ufffc\153\ufffc\154\ufffc\155\ufffc\156\ufffc" +
    "\157\ufffc\001\002\000\040\005\065\047\074\050\056\051" +
    "\100\113\055\117\054\120\067\143\034\144\045\152\023" +
    "\153\073\154\071\155\076\156\024\157\057\001\002\000" +
    "\016\045\uff8a\101\uff8a\114\uff8a\121\uff8a\124\uff8a\150\uff8a" +
    "\001\002\000\102\013\uff61\042\uff61\043\uff61\045\uff61\046" +
    "\uff61\050\uff61\053\uff61\064\uff61\066\uff61\101\uff61\110\uff61" +
    "\111\uff61\114\uff61\115\uff61\116\uff61\117\uff61\120\uff61\121" +
    "\uff61\124\uff61\125\uff61\126\uff61\127\uff61\130\uff61\131\uff61" +
    "\132\uff61\133\uff61\134\uff61\135\uff61\136\uff61\137\uff61\150" +
    "\uff61\151\uff61\001\002\000\042\005\065\047\074\050\056" +
    "\051\100\054\222\113\055\117\054\120\067\143\034\144" +
    "\045\152\023\153\073\154\071\155\076\156\024\157\057" +
    "\001\002\000\006\114\243\121\242\001\002\000\006\133" +
    "\231\134\237\001\002\000\006\133\uffb3\134\uffb3\001\002" +
    "\000\076\013\uff77\042\uff77\046\uff77\050\uff77\053\uff77\064" +
    "\144\066\uff77\110\uff77\111\uff77\112\104\113\105\114\uff77" +
    "\115\uff77\116\uff77\117\uff77\120\uff77\121\uff77\122\102\125" +
    "\uff77\126\uff77\127\uff77\130\uff77\131\uff77\132\uff77\133\uff77" +
    "\134\uff77\135\uff77\136\uff77\150\uff77\151\uff77\001\002\000" +
    "\006\114\235\121\uff99\001\002\000\006\133\uffb2\134\uffb2" +
    "\001\002\000\004\121\224\001\002\000\006\133\uffb5\134" +
    "\uffb5\001\002\000\046\013\uff87\042\123\050\131\053\uff87" +
    "\110\uff87\114\uff87\121\uff87\125\127\126\132\127\125\130" +
    "\130\131\122\132\133\133\uffb6\134\uffb6\135\141\150\uff87" +
    "\151\uff87\001\002\000\042\005\065\047\074\050\056\051" +
    "\100\054\222\113\055\117\054\120\067\143\034\144\045" +
    "\152\023\153\073\154\071\155\076\156\024\157\057\001" +
    "\002\000\006\133\231\134\230\001\002\000\006\114\uff99" +
    "\121\uff99\001\002\000\006\114\uff9b\121\uff9b\001\002\000" +
    "\040\005\065\047\074\050\056\051\100\113\055\117\054" +
    "\120\067\143\034\144\045\152\023\153\073\154\071\155" +
    "\076\156\024\157\057\001\002\000\042\005\065\047\074" +
    "\050\056\051\100\054\222\113\055\117\054\120\067\143" +
    "\034\144\045\152\023\153\073\154\071\155\076\156\024" +
    "\157\057\001\002\000\006\133\uffb1\134\uffb1\001\002\000" +
    "\010\133\uffb6\134\uffb6\135\141\001\002\000\006\114\uff98" +
    "\121\uff98\001\002\000\102\013\uff62\042\uff62\043\uff62\045" +
    "\uff62\046\uff62\050\uff62\053\uff62\064\uff62\066\uff62\101\uff62" +
    "\110\uff62\111\uff62\114\uff62\115\uff62\116\uff62\117\uff62\120" +
    "\uff62\121\uff62\124\uff62\125\uff62\126\uff62\127\uff62\130\uff62" +
    "\131\uff62\132\uff62\133\uff62\134\uff62\135\uff62\136\uff62\137" +
    "\uff62\150\uff62\151\uff62\001\002\000\006\133\uffb4\134\uffb4" +
    "\001\002\000\040\005\065\047\074\050\056\051\100\113" +
    "\055\117\054\120\067\143\034\144\045\152\023\153\073" +
    "\154\071\155\076\156\024\157\057\001\002\000\006\114" +
    "\241\121\uff98\001\002\000\102\013\uff9c\042\uff9c\043\uff9c" +
    "\045\uff9c\046\uff9c\050\uff9c\053\uff9c\064\uff9c\066\uff9c\101" +
    "\uff9c\110\uff9c\111\uff9c\114\uff9c\115\uff9c\116\uff9c\117\uff9c" +
    "\120\uff9c\121\uff9c\124\uff9c\125\uff9c\126\uff9c\127\uff9c\130" +
    "\uff9c\131\uff9c\132\uff9c\133\uff9c\134\uff9c\135\uff9c\136\uff9c" +
    "\137\uff9c\150\uff9c\151\uff9c\001\002\000\042\005\065\047" +
    "\074\050\056\051\100\054\222\113\055\117\054\120\067" +
    "\143\034\144\045\152\023\153\073\154\071\155\076\156" +
    "\024\157\057\001\002\000\102\013\uff9d\042\uff9d\043\uff9d" +
    "\045\uff9d\046\uff9d\050\uff9d\053\uff9d\064\uff9d\066\uff9d\101" +
    "\uff9d\110\uff9d\111\uff9d\114\uff9d\115\uff9d\116\uff9d\117\uff9d" +
    "\120\uff9d\121\uff9d\124\uff9d\125\uff9d\126\uff9d\127\uff9d\130" +
    "\uff9d\131\uff9d\132\uff9d\133\uff9d\134\uff9d\135\uff9d\136\uff9d" +
    "\137\uff9d\150\uff9d\151\uff9d\001\002\000\006\114\uff9a\121" +
    "\uff9a\001\002\000\116\013\uffa4\024\uffa4\025\uffa4\042\uffa4" +
    "\043\uffa4\045\uffa4\046\uffa4\050\uffa4\053\uffa4\064\uffa4\066" +
    "\uffa4\101\uffa4\105\uffa4\110\uffa4\111\uffa4\112\uffa4\113\uffa4" +
    "\114\uffa4\115\uffa4\116\uffa4\117\uffa4\120\uffa4\121\uffa4\122" +
    "\uffa4\124\uffa4\125\uffa4\126\uffa4\127\uffa4\130\uffa4\131\uffa4" +
    "\132\uffa4\133\uffa4\134\uffa4\135\uffa4\136\uffa4\137\uffa4\150" +
    "\uffa4\151\uffa4\001\002\000\116\013\uffa5\024\uffa5\025\uffa5" +
    "\042\uffa5\043\uffa5\045\uffa5\046\uffa5\050\uffa5\053\uffa5\064" +
    "\uffa5\066\uffa5\101\uffa5\105\uffa5\110\uffa5\111\uffa5\112\uffa5" +
    "\113\uffa5\114\uffa5\115\uffa5\116\uffa5\117\uffa5\120\uffa5\121" +
    "\uffa5\122\uffa5\124\uffa5\125\uffa5\126\uffa5\127\uffa5\130\uffa5" +
    "\131\uffa5\132\uffa5\133\uffa5\134\uffa5\135\uffa5\136\uffa5\137" +
    "\uffa5\150\uffa5\151\uffa5\001\002\000\116\013\uffa3\024\uffa3" +
    "\025\uffa3\042\uffa3\043\uffa3\045\uffa3\046\uffa3\050\uffa3\053" +
    "\uffa3\064\uffa3\066\uffa3\101\uffa3\105\uffa3\110\uffa3\111\uffa3" +
    "\112\uffa3\113\uffa3\114\uffa3\115\uffa3\116\uffa3\117\uffa3\120" +
    "\uffa3\121\uffa3\122\uffa3\124\uffa3\125\uffa3\126\uffa3\127\uffa3" +
    "\130\uffa3\131\uffa3\132\uffa3\133\uffa3\134\uffa3\135\uffa3\136" +
    "\uffa3\137\uffa3\150\uffa3\151\uffa3\001\002\000\070\013\uff80" +
    "\042\uff80\043\uff80\045\uff80\050\uff80\053\uff80\064\uff80\101" +
    "\uff80\110\uff80\111\254\114\uff80\117\251\120\252\121\uff80" +
    "\124\uff80\125\uff80\126\uff80\127\uff80\130\uff80\131\uff80\132" +
    "\uff80\133\uff80\134\uff80\135\uff80\137\uff80\150\uff80\151\uff80" +
    "\001\002\000\030\047\uff6d\051\uff6d\113\uff6d\143\uff6d\144" +
    "\uff6d\152\uff6d\153\uff6d\154\uff6d\155\uff6d\156\uff6d\157\uff6d" +
    "\001\002\000\030\047\uff6c\051\uff6c\113\uff6c\143\uff6c\144" +
    "\uff6c\152\uff6c\153\uff6c\154\uff6c\155\uff6c\156\uff6c\157\uff6c" +
    "\001\002\000\030\047\074\051\100\113\055\143\034\144" +
    "\045\152\023\153\073\154\071\155\076\156\024\157\057" +
    "\001\002\000\030\047\uff6b\051\uff6b\113\uff6b\143\uff6b\144" +
    "\uff6b\152\uff6b\153\uff6b\154\uff6b\155\uff6b\156\uff6b\157\uff6b" +
    "\001\002\000\100\013\uff7e\042\uff7e\043\uff7e\045\uff7e\046" +
    "\256\050\uff7e\053\uff7e\064\uff7e\066\260\101\uff7e\110\uff7e" +
    "\111\uff7e\114\uff7e\115\262\116\261\117\uff7e\120\uff7e\121" +
    "\uff7e\124\uff7e\125\uff7e\126\uff7e\127\uff7e\130\uff7e\131\uff7e" +
    "\132\uff7e\133\uff7e\134\uff7e\135\uff7e\137\uff7e\150\uff7e\151" +
    "\uff7e\001\002\000\030\047\uff64\051\uff64\113\uff64\143\uff64" +
    "\144\uff64\152\uff64\153\uff64\154\uff64\155\uff64\156\uff64\157" +
    "\uff64\001\002\000\030\047\074\051\100\113\055\143\034" +
    "\144\045\152\023\153\073\154\071\155\076\156\024\157" +
    "\057\001\002\000\030\047\uff63\051\uff63\113\uff63\143\uff63" +
    "\144\uff63\152\uff63\153\uff63\154\uff63\155\uff63\156\uff63\157" +
    "\uff63\001\002\000\030\047\uff65\051\uff65\113\uff65\143\uff65" +
    "\144\uff65\152\uff65\153\uff65\154\uff65\155\uff65\156\uff65\157" +
    "\uff65\001\002\000\030\047\uff66\051\uff66\113\uff66\143\uff66" +
    "\144\uff66\152\uff66\153\uff66\154\uff66\155\uff66\156\uff66\157" +
    "\uff66\001\002\000\100\013\uff7c\042\uff7c\043\uff7c\045\uff7c" +
    "\046\uff7c\050\uff7c\053\uff7c\064\uff7c\066\uff7c\101\uff7c\110" +
    "\uff7c\111\uff7c\114\uff7c\115\uff7c\116\uff7c\117\uff7c\120\uff7c" +
    "\121\uff7c\124\uff7c\125\uff7c\126\uff7c\127\uff7c\130\uff7c\131" +
    "\uff7c\132\uff7c\133\uff7c\134\uff7c\135\uff7c\137\uff7c\150\uff7c" +
    "\151\uff7c\001\002\000\106\013\uff60\042\uff60\043\uff60\045" +
    "\uff60\046\uff60\050\uff60\053\uff60\064\uff60\066\uff60\101\uff60" +
    "\110\uff60\111\uff60\113\105\114\uff60\115\uff60\116\uff60\117" +
    "\uff60\120\uff60\121\uff60\122\102\124\uff60\125\uff60\126\uff60" +
    "\127\uff60\130\uff60\131\uff60\132\uff60\133\uff60\134\uff60\135" +
    "\uff60\136\uff60\137\uff60\150\uff60\151\uff60\001\002\000\030" +
    "\047\074\051\100\113\055\143\034\144\045\152\023\153" +
    "\073\154\071\155\076\156\024\157\057\001\002\000\100" +
    "\013\uff7a\042\uff7a\043\uff7a\045\uff7a\046\uff7a\050\uff7a\053" +
    "\uff7a\064\uff7a\066\uff7a\101\uff7a\110\uff7a\111\uff7a\114\uff7a" +
    "\115\uff7a\116\uff7a\117\uff7a\120\uff7a\121\uff7a\124\uff7a\125" +
    "\uff7a\126\uff7a\127\uff7a\130\uff7a\131\uff7a\132\uff7a\133\uff7a" +
    "\134\uff7a\135\uff7a\137\uff7a\150\uff7a\151\uff7a\001\002\000" +
    "\032\013\uffd0\043\uffd0\045\uffd0\053\uffd0\101\uffd0\110\uffd0" +
    "\114\uffd0\121\uffd0\124\uffd0\137\uffd0\150\uffd0\151\uffd0\001" +
    "\002\000\032\013\uffd1\043\uffd1\045\uffd1\053\uffd1\101\uffd1" +
    "\110\uffd1\114\uffd1\121\uffd1\124\uffd1\137\uffd1\150\uffd1\151" +
    "\uffd1\001\002\000\006\114\272\121\uff99\001\002\000\102" +
    "\013\uff74\042\uff74\043\uff74\045\uff74\046\uff74\050\uff74\053" +
    "\uff74\064\uff74\066\uff74\101\uff74\110\uff74\111\uff74\114\uff74" +
    "\115\uff74\116\uff74\117\uff74\120\uff74\121\uff74\124\uff74\125" +
    "\uff74\126\uff74\127\uff74\130\uff74\131\uff74\132\uff74\133\uff74" +
    "\134\uff74\135\uff74\136\uff74\137\uff74\150\uff74\151\uff74\001" +
    "\002\000\034\013\uffd2\043\uffd2\045\uffd2\053\uffd2\064\144" +
    "\101\uffd2\110\uffd2\114\uffd2\121\uffd2\124\uffd2\137\uffd2\150" +
    "\uffd2\151\uffd2\001\002\000\032\013\uffd3\043\uffd3\045\uffd3" +
    "\053\uffd3\101\uffd3\110\uffd3\114\uffd3\121\uffd3\124\uffd3\137" +
    "\uffd3\150\uffd3\151\uffd3\001\002\000\116\013\uff0e\024\uff0e" +
    "\025\uff0e\042\uff0e\043\uff0e\045\uff0e\046\uff0e\050\uff0e\053" +
    "\uff0e\064\uff0e\066\uff0e\101\uff0e\105\uff0e\110\uff0e\111\uff0e" +
    "\112\uff0e\113\uff0e\114\uff0e\115\uff0e\116\uff0e\117\uff0e\120" +
    "\uff0e\121\uff0e\122\uff0e\124\uff0e\125\uff0e\126\uff0e\127\uff0e" +
    "\130\uff0e\131\uff0e\132\uff0e\133\uff0e\134\uff0e\135\uff0e\136" +
    "\uff0e\137\uff0e\150\uff0e\151\uff0e\001\002\000\040\005\065" +
    "\047\074\050\056\051\100\113\055\117\054\120\067\143" +
    "\034\144\045\152\023\153\073\154\071\155\076\156\024" +
    "\157\057\001\002\000\032\013\uffd9\043\uffd9\045\uffd9\053" +
    "\uffd9\101\uffd9\110\uffd9\114\uffd9\121\uffd9\124\uffd9\137\uffd9" +
    "\150\uffd9\151\uffd9\001\002\000\020\003\uff27\016\uff27\036" +
    "\uff27\061\uff27\075\uff27\102\uff27\152\uff27\001\002\000\116" +
    "\013\uff0f\024\uff0f\025\uff0f\042\uff0f\043\uff0f\045\uff0f\046" +
    "\uff0f\050\uff0f\053\uff0f\064\uff0f\066\uff0f\101\uff0f\105\uff0f" +
    "\110\uff0f\111\uff0f\112\uff0f\113\uff0f\114\uff0f\115\uff0f\116" +
    "\uff0f\117\uff0f\120\uff0f\121\uff0f\122\uff0f\124\uff0f\125\uff0f" +
    "\126\uff0f\127\uff0f\130\uff0f\131\uff0f\132\uff0f\133\uff0f\134" +
    "\uff0f\135\uff0f\136\uff0f\137\uff0f\150\uff0f\151\uff0f\001\002" +
    "\000\006\114\uff23\124\327\001\002\000\006\121\321\123" +
    "\322\001\002\000\006\114\uff1f\124\uff1f\001\002\000\006" +
    "\121\306\123\307\001\002\000\004\152\023\001\002\000" +
    "\024\042\311\055\310\143\uff1b\144\uff1b\145\uff1b\146\uff1b" +
    "\147\uff1b\152\uff1b\156\uff1b\001\002\000\020\143\uff19\144" +
    "\uff19\145\uff19\146\uff19\147\uff19\152\uff19\156\uff19\001\002" +
    "\000\022\055\317\143\uff1a\144\uff1a\145\uff1a\146\uff1a\147" +
    "\uff1a\152\uff1a\156\uff1a\001\002\000\020\143\034\144\045" +
    "\145\035\146\033\147\046\152\023\156\024\001\002\000" +
    "\010\114\uffea\124\uffea\137\314\001\002\000\040\005\065" +
    "\047\074\050\056\051\100\113\055\117\054\120\067\143" +
    "\034\144\045\152\023\153\073\154\071\155\076\156\024" +
    "\157\057\001\002\000\006\114\uff1c\124\uff1c\001\002\000" +
    "\006\114\uffe9\124\uffe9\001\002\000\020\143\uff18\144\uff18" +
    "\145\uff18\146\uff18\147\uff18\152\uff18\156\uff18\001\002\000" +
    "\006\121\uffe5\123\uffe5\001\002\000\004\152\023\001\002" +
    "\000\024\042\311\055\310\143\uff1b\144\uff1b\145\uff1b\146" +
    "\uff1b\147\uff1b\152\uff1b\156\uff1b\001\002\000\020\143\034" +
    "\144\045\145\035\146\033\147\046\152\023\156\024\001" +
    "\002\000\010\114\uffea\124\uffea\137\314\001\002\000\006" +
    "\114\uff1d\124\uff1d\001\002\000\006\121\uffe6\123\uffe6\001" +
    "\002\000\004\152\023\001\002\000\004\114\331\001\002" +
    "\000\010\043\uff22\071\uff22\124\uff22\001\002\000\006\114" +
    "\uff1e\124\uff1e\001\002\000\004\002\001\001\002\000\010" +
    "\002\uff0a\036\uff0a\061\uff0a\001\002\000\010\043\336\113" +
    "\026\124\uff21\001\002\000\020\003\uff29\016\uff29\036\uff29" +
    "\061\uff29\075\uff29\102\uff29\152\uff29\001\002\000\006\043" +
    "\341\124\uff20\001\002\000\004\124\uff2b\001\002\000\020" +
    "\003\uff28\016\uff28\036\uff28\061\uff28\075\uff28\102\uff28\152" +
    "\uff28\001\002\000\004\016\u013c\001\002\000\020\003\355" +
    "\016\uffaf\036\014\061\006\075\350\102\352\152\023\001" +
    "\002\000\020\003\uffed\016\uffed\036\uffed\061\uffed\075\uffed" +
    "\102\uffed\152\uffed\001\002\000\020\003\uffac\016\uffac\036" +
    "\uffac\061\uffac\075\uffac\102\uffac\152\uffac\001\002\000\020" +
    "\003\ufff1\016\ufff1\036\ufff1\061\ufff1\075\ufff1\102\ufff1\152" +
    "\ufff1\001\002\000\006\121\321\123\u0133\001\002\000\004" +
    "\152\023\001\002\000\020\003\uffad\016\uffad\036\uffad\061" +
    "\uffad\075\uffad\102\uffad\152\uffad\001\002\000\004\152\023" +
    "\001\002\000\020\003\uffee\016\uffee\036\uffee\061\uffee\075" +
    "\uffee\102\uffee\152\uffee\001\002\000\020\003\ufff0\016\ufff0" +
    "\036\ufff0\061\ufff0\075\ufff0\102\ufff0\152\ufff0\001\002\000" +
    "\004\124\373\001\002\000\006\121\306\123\362\001\002" +
    "\000\020\003\uffef\016\uffef\036\uffef\061\uffef\075\uffef\102" +
    "\uffef\152\uffef\001\002\000\020\003\uffe3\016\uffe3\036\uffe3" +
    "\061\uffe3\075\uffe3\102\uffe3\152\uffe3\001\002\000\020\003" +
    "\uffab\016\uffab\036\uffab\061\uffab\075\uffab\102\uffab\152\uffab" +
    "\001\002\000\022\021\363\143\000\144\000\145\000\146" +
    "\000\147\000\152\000\156\000\001\002\000\022\137\370" +
    "\143\uffff\144\uffff\145\uffff\146\uffff\147\uffff\152\uffff\156" +
    "\uffff\001\002\000\020\143\034\144\045\145\035\146\033" +
    "\147\046\152\023\156\024\001\002\000\006\124\uffea\137" +
    "\314\001\002\000\004\124\367\001\002\000\020\003\uffeb" +
    "\016\uffeb\036\uffeb\061\uffeb\075\uffeb\102\uffeb\152\uffeb\001" +
    "\002\000\040\005\065\047\074\050\056\051\100\113\055" +
    "\117\054\120\067\143\034\144\045\152\023\153\073\154" +
    "\071\155\076\156\024\157\057\001\002\000\004\124\372" +
    "\001\002\000\020\003\uffe7\016\uffe7\036\uffe7\061\uffe7\075" +
    "\uffe7\102\uffe7\152\uffe7\001\002\000\020\003\uffaa\016\uffaa" +
    "\036\uffaa\061\uffaa\075\uffaa\102\uffaa\152\uffaa\001\002\000" +
    "\010\043\uffe2\113\376\124\uffe2\001\002\000\006\043\u010e" +
    "\124\u010d\001\002\000\004\152\023\001\002\000\006\043" +
    "\uffe1\124\uffe1\001\002\000\006\114\u010a\124\u010b\001\002" +
    "\000\006\114\uffbd\124\uffbd\001\002\000\006\121\321\123" +
    "\u0107\001\002\000\006\121\306\123\u0104\001\002\000\020" +
    "\143\034\144\045\145\035\146\033\147\046\152\023\156" +
    "\024\001\002\000\010\114\uffea\124\uffea\137\314\001\002" +
    "\000\006\114\uffba\124\uffba\001\002\000\020\143\034\144" +
    "\045\145\035\146\033\147\046\152\023\156\024\001\002" +
    "\000\010\114\uffea\124\uffea\137\314\001\002\000\006\114" +
    "\uffbb\124\uffbb\001\002\000\006\043\uffbe\124\uffbe\001\002" +
    "\000\004\152\023\001\002\000\006\114\uffbc\124\uffbc\001" +
    "\002\000\020\003\uffb0\016\uffb0\036\uffb0\061\uffb0\075\uffb0" +
    "\102\uffb0\152\uffb0\001\002\000\004\065\u010f\001\002\000" +
    "\014\003\uffcc\020\uffcc\031\uffcc\051\uffcc\152\uffcc\001\002" +
    "\000\004\124\u0112\001\002\000\004\124\uffe0\001\002\000" +
    "\020\003\uffe4\016\uffe4\036\uffe4\061\uffe4\075\uffe4\102\uffe4" +
    "\152\uffe4\001\002\000\014\003\uffc5\020\uffc5\031\uffc5\051" +
    "\u0116\152\uffc5\001\002\000\014\003\u011e\020\uffc9\031\uffc9" +
    "\105\uffc9\152\023\001\002\000\004\031\uffcb\001\002\000" +
    "\004\124\uffc7\001\002\000\004\124\u0118\001\002\000\006" +
    "\031\uffc6\105\uffc6\001\002\000\004\031\u011a\001\002\000" +
    "\004\065\u011b\001\002\000\004\124\uffca\001\002\000\010" +
    "\020\u0124\031\uffc3\105\uffc3\001\002\000\004\124\uffc1\001" +
    "\002\000\014\003\uffbf\020\uffbf\031\uffbf\105\uffbf\152\uffbf" +
    "\001\002\000\014\003\uffc4\020\uffc4\031\uffc4\105\uffc4\152" +
    "\uffc4\001\002\000\004\124\u0121\001\002\000\014\003\uffc0" +
    "\020\uffc0\031\uffc0\105\uffc0\152\uffc0\001\002\000\006\031" +
    "\uffc2\105\uffc2\001\002\000\006\031\uffc8\105\uffc8\001\002" +
    "\000\012\143\034\144\045\152\023\156\024\001\002\000" +
    "\010\043\u0126\113\105\122\102\001\002\000\006\031\uffb8" +
    "\105\uffb8\001\002\000\006\031\u0129\105\u0128\001\002\000" +
    "\042\005\065\047\074\050\056\051\100\054\222\113\055" +
    "\117\054\120\067\143\034\144\045\152\023\153\073\154" +
    "\071\155\076\156\024\157\057\001\002\000\004\020\u012a" +
    "\001\002\000\004\124\u012b\001\002\000\006\031\uffb9\105" +
    "\uffb9\001\002\000\006\133\231\134\u012d\001\002\000\016" +
    "\003\uffc5\020\uffc5\031\uffc5\051\u0116\105\uffc5\152\uffc5\001" +
    "\002\000\006\031\uffb7\105\uffb7\001\002\000\004\043\u0130" +
    "\001\002\000\020\143\034\144\045\145\035\146\033\147" +
    "\046\152\023\156\024\001\002\000\004\124\u0132\001\002" +
    "\000\020\003\uffdf\016\uffdf\036\uffdf\061\uffdf\075\uffdf\102" +
    "\uffdf\152\uffdf\001\002\000\022\021\u0134\143\000\144\000" +
    "\145\000\146\000\147\000\152\000\156\000\001\002\000" +
    "\022\137\u0139\143\uffff\144\uffff\145\uffff\146\uffff\147\uffff" +
    "\152\uffff\156\uffff\001\002\000\020\143\034\144\045\145" +
    "\035\146\033\147\046\152\023\156\024\001\002\000\006" +
    "\124\uffea\137\314\001\002\000\004\124\u0138\001\002\000" +
    "\020\003\uffec\016\uffec\036\uffec\061\uffec\075\uffec\102\uffec" +
    "\152\uffec\001\002\000\040\005\065\047\074\050\056\051" +
    "\100\113\055\117\054\120\067\143\034\144\045\152\023" +
    "\153\073\154\071\155\076\156\024\157\057\001\002\000" +
    "\004\124\u013b\001\002\000\020\003\uffe8\016\uffe8\036\uffe8" +
    "\061\uffe8\075\uffe8\102\uffe8\152\uffe8\001\002\000\042\003" +
    "\uff17\016\uff17\022\uff17\034\uff17\035\uff17\040\uff17\041\uff17" +
    "\045\uff17\051\uff17\071\uff17\106\uff17\140\uff17\143\uff17\144" +
    "\uff17\152\uff17\156\uff17\001\002\000\042\003\u013f\016\uff5a" +
    "\022\uff5a\034\uff5a\035\uff5a\040\uff5a\041\uff5a\045\uff5a\051" +
    "\uff5a\071\uff5a\106\uff5a\140\uff5a\143\uff5a\144\uff5a\152\uff5a" +
    "\156\uff5a\001\002\000\044\003\u013f\016\uff5a\022\uff5a\031" +
    "\u01b5\034\uff5a\035\uff5a\040\uff5a\041\uff5a\045\uff5a\051\uff5a" +
    "\071\uff5a\106\uff5a\140\uff5a\143\uff5a\144\uff5a\152\uff5a\156" +
    "\uff5a\001\002\000\050\003\uff5b\016\uff5b\022\uff5b\027\uff5b" +
    "\030\uff5b\031\uff5b\034\uff5b\035\uff5b\040\uff5b\041\uff5b\045" +
    "\uff5b\051\uff5b\071\uff5b\106\uff5b\140\uff5b\143\uff5b\144\uff5b" +
    "\152\uff5b\156\uff5b\001\002\000\040\016\uff36\022\u015b\034" +
    "\u0142\035\u0157\040\u0146\041\u014a\045\uff3e\051\u0158\071\u0149" +
    "\106\u0147\140\u0154\143\034\144\045\152\023\156\024\001" +
    "\002\000\050\003\uff5f\016\uff5f\022\uff5f\027\uff5f\030\uff5f" +
    "\031\uff5f\034\uff5f\035\uff5f\040\uff5f\041\uff5f\045\uff5f\051" +
    "\uff5f\071\uff5f\106\uff5f\140\uff5f\143\uff5f\144\uff5f\152\uff5f" +
    "\156\uff5f\001\002\000\016\105\uff33\124\uff33\143\034\144" +
    "\045\152\023\156\024\001\002\000\050\003\uff52\016\uff52" +
    "\022\uff52\027\uff52\030\uff52\031\uff52\034\uff52\035\uff52\040" +
    "\uff52\041\uff52\045\uff52\051\uff52\071\uff52\106\uff52\140\uff52" +
    "\143\uff52\144\uff52\152\uff52\156\uff52\001\002\000\016\112" +
    "\uffa9\113\uffa9\122\uffa9\123\u01a2\124\uffa9\137\uffa9\001\002" +
    "\000\050\003\uff51\016\uff51\022\uff51\027\uff51\030\uff51\031" +
    "\uff51\034\uff51\035\uff51\040\uff51\041\uff51\045\uff51\051\uff51" +
    "\071\uff51\106\uff51\140\uff51\143\uff51\144\uff51\152\uff51\156" +
    "\uff51\001\002\000\012\143\034\144\045\152\023\156\024" +
    "\001\002\000\040\005\ufffc\047\ufffc\050\ufffc\051\ufffc\113" +
    "\ufffc\117\ufffc\120\ufffc\143\ufffc\144\ufffc\152\ufffc\153\ufffc" +
    "\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001\002\000\050\003" +
    "\uff58\016\uff58\022\uff58\027\uff58\030\uff58\031\uff58\034\uff58" +
    "\035\uff58\040\uff58\041\uff58\045\uff58\051\uff58\071\uff58\106" +
    "\uff58\140\uff58\143\uff58\144\uff58\152\uff58\156\uff58\001\002" +
    "\000\042\005\065\047\074\050\056\051\100\113\055\117" +
    "\054\120\067\124\u019b\143\034\144\045\152\023\153\073" +
    "\154\071\155\076\156\024\157\057\001\002\000\040\005" +
    "\065\047\074\050\056\051\100\113\055\117\054\120\067" +
    "\143\034\144\045\152\023\153\073\154\071\155\076\156" +
    "\024\157\057\001\002\000\050\003\uff57\016\uff57\022\uff57" +
    "\027\uff57\030\uff57\031\uff57\034\uff57\035\uff57\040\uff57\041" +
    "\uff57\045\uff57\051\uff57\071\uff57\106\uff57\140\uff57\143\uff57" +
    "\144\uff57\152\uff57\156\uff57\001\002\000\050\003\uff5c\016" +
    "\uff5c\022\uff5c\027\uff5c\030\uff5c\031\uff5c\034\uff5c\035\uff5c" +
    "\040\uff5c\041\uff5c\045\uff5c\051\uff5c\071\uff5c\106\uff5c\140" +
    "\uff5c\143\uff5c\144\uff5c\152\uff5c\156\uff5c\001\002\000\040" +
    "\016\uff59\022\uff59\034\uff59\035\uff59\040\uff59\041\uff59\045" +
    "\uff59\051\uff59\071\uff59\106\uff59\140\uff59\143\uff59\144\uff59" +
    "\152\uff59\156\uff59\001\002\000\050\003\uff4f\016\uff4f\022" +
    "\uff4f\027\uff4f\030\uff4f\031\uff4f\034\uff4f\035\uff4f\040\uff4f" +
    "\041\uff4f\045\uff4f\051\uff4f\071\uff4f\106\uff4f\140\uff4f\143" +
    "\uff4f\144\uff4f\152\uff4f\156\uff4f\001\002\000\050\003\uff53" +
    "\016\uff53\022\uff53\027\uff53\030\uff53\031\uff53\034\uff53\035" +
    "\uff53\040\uff53\041\uff53\045\uff53\051\uff53\071\uff53\106\uff53" +
    "\140\uff53\143\uff53\144\uff53\152\uff53\156\uff53\001\002\000" +
    "\050\003\uff50\016\uff50\022\uff50\027\uff50\030\uff50\031\uff50" +
    "\034\uff50\035\uff50\040\uff50\041\uff50\045\uff50\051\uff50\071" +
    "\uff50\106\uff50\140\uff50\143\uff50\144\uff50\152\uff50\156\uff50" +
    "\001\002\000\004\016\u017e\001\002\000\004\045\ufffc\001" +
    "\002\000\050\003\uff54\016\uff54\022\uff54\027\uff54\030\uff54" +
    "\031\uff54\034\uff54\035\uff54\040\uff54\041\uff54\045\uff54\051" +
    "\uff54\071\uff54\106\uff54\140\uff54\143\uff54\144\uff54\152\uff54" +
    "\156\uff54\001\002\000\004\152\023\001\002\000\050\003" +
    "\uff56\016\uff56\022\uff56\027\uff56\030\uff56\031\uff56\034\uff56" +
    "\035\uff56\040\uff56\041\uff56\045\uff56\051\uff56\071\uff56\106" +
    "\uff56\140\uff56\143\uff56\144\uff56\152\uff56\156\uff56\001\002" +
    "\000\004\124\u0170\001\002\000\004\152\023\001\002\000" +
    "\004\124\u0162\001\002\000\050\003\uff55\016\uff55\022\uff55" +
    "\027\uff55\030\uff55\031\uff55\034\uff55\035\uff55\040\uff55\041" +
    "\uff55\045\uff55\051\uff55\071\uff55\106\uff55\140\uff55\143\uff55" +
    "\144\uff55\152\uff55\156\uff55\001\002\000\050\003\uff5d\016" +
    "\uff5d\022\uff5d\027\uff5d\030\uff5d\031\uff5d\034\uff5d\035\uff5d" +
    "\040\uff5d\041\uff5d\045\uff5d\051\uff5d\071\uff5d\106\uff5d\140" +
    "\uff5d\143\uff5d\144\uff5d\152\uff5d\156\uff5d\001\002\000\020" +
    "\003\uffae\016\uffae\036\uffae\061\uffae\075\uffae\102\uffae\152" +
    "\uffae\001\002\000\014\112\104\113\105\122\102\124\u015e" +
    "\137\u015d\001\002\000\040\005\065\047\074\050\056\051" +
    "\100\113\055\117\054\120\067\143\034\144\045\152\023" +
    "\153\073\154\071\155\076\156\024\157\057\001\002\000" +
    "\050\003\uff12\016\uff12\022\uff12\027\uff12\030\uff12\031\uff12" +
    "\034\uff12\035\uff12\040\uff12\041\uff12\045\uff12\051\uff12\071" +
    "\uff12\106\uff12\140\uff12\143\uff12\144\uff12\152\uff12\156\uff12" +
    "\001\002\000\004\124\u0160\001\002\000\050\003\uff4c\016" +
    "\uff4c\022\uff4c\027\uff4c\030\uff4c\031\uff4c\034\uff4c\035\uff4c" +
    "\040\uff4c\041\uff4c\045\uff4c\051\uff4c\071\uff4c\106\uff4c\140" +
    "\uff4c\143\uff4c\144\uff4c\152\uff4c\156\uff4c\001\002\000\004" +
    "\016\uff35\001\002\000\050\003\uff4d\016\uff4d\022\uff4d\027" +
    "\uff4d\030\uff4d\031\uff4d\034\uff4d\035\uff4d\040\uff4d\041\uff4d" +
    "\045\uff4d\051\uff4d\071\uff4d\106\uff4d\140\uff4d\143\uff4d\144" +
    "\uff4d\152\uff4d\156\uff4d\001\002\000\004\042\u0164\001\002" +
    "\000\046\005\065\047\074\050\056\051\100\072\u0166\113" +
    "\055\117\054\120\067\143\034\144\045\146\033\147\u0169" +
    "\152\023\153\073\154\071\155\076\156\024\157\057\001" +
    "\002\000\004\045\uffcd\001\002\000\044\005\065\047\074" +
    "\050\056\051\100\113\055\117\054\120\067\143\034\144" +
    "\045\146\033\147\u0169\152\023\153\073\154\071\155\076" +
    "\156\024\157\057\001\002\000\036\045\uffd2\046\uff77\064" +
    "\144\066\uff77\111\uff77\112\104\113\105\115\uff77\116\uff77" +
    "\117\uff77\120\uff77\122\102\135\uff77\136\uff77\001\002\000" +
    "\006\045\uffd2\064\144\001\002\000\006\045\ufff9\064\ufff9" +
    "\001\002\000\004\045\ufffc\001\002\000\004\045\uff3d\001" +
    "\002\000\004\045\uffce\001\002\000\004\045\uffcf\001\002" +
    "\000\004\045\ufffc\001\002\000\004\045\uff3c\001\002\000" +
    "\050\003\uff06\016\uff06\022\uff06\027\uff06\030\uff06\031\uff06" +
    "\034\uff06\035\uff06\040\uff06\041\uff06\045\uff06\051\uff06\071" +
    "\uff06\106\uff06\140\uff06\143\uff06\144\uff06\152\uff06\156\uff06" +
    "\001\002\000\004\141\u0172\001\002\000\040\016\uff4e\022" +
    "\uff4e\034\uff4e\035\uff4e\040\uff4e\041\uff4e\045\uff4e\051\uff4e" +
    "\071\uff4e\106\uff4e\140\uff4e\143\uff4e\144\uff4e\152\uff4e\156" +
    "\uff4e\001\002\000\004\045\u0175\001\002\000\004\124\u017b" +
    "\001\002\000\042\003\uff40\016\uff40\022\uff40\034\uff40\035" +
    "\uff40\040\uff40\041\uff40\045\uff40\051\uff40\071\uff40\106\uff40" +
    "\140\uff40\143\uff40\144\uff40\152\uff40\156\uff40\001\002\000" +
    "\042\003\u013f\016\uff5a\022\uff5a\034\uff5a\035\uff5a\040\uff5a" +
    "\041\uff5a\045\uff5a\051\uff5a\071\uff5a\106\uff5a\140\uff5a\143" +
    "\uff5a\144\uff5a\152\uff5a\156\uff5a\001\002\000\044\003\u013f" +
    "\016\uff5a\022\uff5a\031\u0179\034\uff5a\035\uff5a\040\uff5a\041" +
    "\uff5a\045\uff5a\051\uff5a\071\uff5a\106\uff5a\140\uff5a\143\uff5a" +
    "\144\uff5a\152\uff5a\156\uff5a\001\002\000\050\003\uff5e\016" +
    "\uff5e\022\uff5e\027\uff5e\030\uff5e\031\uff5e\034\uff5e\035\uff5e" +
    "\040\uff5e\041\uff5e\045\uff5e\051\uff5e\071\uff5e\106\uff5e\140" +
    "\uff5e\143\uff5e\144\uff5e\152\uff5e\156\uff5e\001\002\000\004" +
    "\045\u017a\001\002\000\006\124\uff3f\152\uff3f\001\002\000" +
    "\050\003\uff43\016\uff43\022\uff43\027\uff43\030\uff43\031\uff43" +
    "\034\uff43\035\uff43\040\uff43\041\uff43\045\uff43\051\uff43\071" +
    "\uff43\106\uff43\140\uff43\143\uff43\144\uff43\152\uff43\156\uff43" +
    "\001\002\000\050\003\ufffd\016\ufffd\022\ufffd\027\ufffd\030" +
    "\ufffd\031\ufffd\034\ufffd\035\ufffd\040\ufffd\041\ufffd\045\ufffd" +
    "\051\ufffd\071\ufffd\106\ufffd\140\ufffd\143\ufffd\144\ufffd\152" +
    "\ufffd\156\ufffd\001\002\000\050\003\uff42\016\uff42\022\uff42" +
    "\027\uff42\030\uff42\031\uff42\034\uff42\035\uff42\040\uff42\041" +
    "\uff42\045\uff42\051\uff42\071\uff42\106\uff42\140\uff42\143\uff42" +
    "\144\uff42\152\uff42\156\uff42\001\002\000\042\003\uff3a\016" +
    "\uff3a\022\uff3a\034\uff3a\035\uff3a\040\uff3a\041\uff3a\045\uff3a" +
    "\051\uff3a\071\uff3a\106\uff3a\140\uff3a\143\uff3a\144\uff3a\152" +
    "\uff3a\156\uff3a\001\002\000\042\003\u013f\016\uff5a\022\uff5a" +
    "\034\uff5a\035\uff5a\040\uff5a\041\uff5a\045\uff5a\051\uff5a\071" +
    "\uff5a\106\uff5a\140\uff5a\143\uff5a\144\uff5a\152\uff5a\156\uff5a" +
    "\001\002\000\044\003\u013f\016\uff5a\022\uff5a\031\u0181\034" +
    "\uff5a\035\uff5a\040\uff5a\041\uff5a\045\uff5a\051\uff5a\071\uff5a" +
    "\106\uff5a\140\uff5a\143\uff5a\144\uff5a\152\uff5a\156\uff5a\001" +
    "\002\000\004\124\u0182\001\002\000\050\003\uff39\016\uff39" +
    "\022\uff39\027\uff39\030\uff39\031\uff39\034\uff39\035\uff39\040" +
    "\uff39\041\uff39\045\uff39\051\uff39\071\uff39\106\uff39\140\uff39" +
    "\143\uff39\144\uff39\152\uff39\156\uff39\001\002\000\004\101" +
    "\uff4b\001\002\000\010\045\uff44\101\uff44\124\uff44\001\002" +
    "\000\004\101\u0186\001\002\000\042\003\uff4a\016\uff4a\022" +
    "\uff4a\034\uff4a\035\uff4a\040\uff4a\041\uff4a\045\uff4a\051\uff4a" +
    "\071\uff4a\106\uff4a\140\uff4a\143\uff4a\144\uff4a\152\uff4a\156" +
    "\uff4a\001\002\000\042\003\ufffc\016\ufffc\022\ufffc\034\ufffc" +
    "\035\ufffc\040\ufffc\041\ufffc\045\ufffc\051\ufffc\071\ufffc\106" +
    "\ufffc\140\ufffc\143\ufffc\144\ufffc\152\ufffc\156\ufffc\001\002" +
    "\000\042\003\u013f\016\uff5a\022\uff5a\034\uff5a\035\uff5a\040" +
    "\uff5a\041\uff5a\045\uff5a\051\uff5a\071\uff5a\106\uff5a\140\uff5a" +
    "\143\uff5a\144\uff5a\152\uff5a\156\uff5a\001\002\000\050\003" +
    "\u013f\016\uff5a\022\uff5a\027\ufffb\030\ufffb\031\ufffb\034\uff5a" +
    "\035\uff5a\040\uff5a\041\uff5a\045\uff5a\051\uff5a\071\uff5a\106" +
    "\uff5a\140\uff5a\143\uff5a\144\uff5a\152\uff5a\156\uff5a\001\002" +
    "\000\010\027\ufffc\030\ufffc\031\ufffc\001\002\000\010\027" +
    "\uff48\030\uff48\031\uff48\001\002\000\010\027\ufffb\030\ufffb" +
    "\031\ufffb\001\002\000\010\027\u018f\030\ufffc\031\uff46\001" +
    "\002\000\004\030\u0196\001\002\000\042\003\ufffc\016\ufffc" +
    "\022\ufffc\034\ufffc\035\ufffc\040\ufffc\041\ufffc\045\ufffc\051" +
    "\ufffc\071\ufffc\106\ufffc\140\ufffc\143\ufffc\144\ufffc\152\ufffc" +
    "\156\ufffc\001\002\000\004\031\u0191\001\002\000\004\041" +
    "\u0192\001\002\000\004\124\u0193\001\002\000\050\003\uff49" +
    "\016\uff49\022\uff49\027\uff49\030\uff49\031\uff49\034\uff49\035" +
    "\uff49\040\uff49\041\uff49\045\uff49\051\uff49\071\uff49\106\uff49" +
    "\140\uff49\143\uff49\144\uff49\152\uff49\156\uff49\001\002\000" +
    "\042\003\u013f\016\uff5a\022\uff5a\034\uff5a\035\uff5a\040\uff5a" +
    "\041\uff5a\045\uff5a\051\uff5a\071\uff5a\106\uff5a\140\uff5a\143" +
    "\uff5a\144\uff5a\152\uff5a\156\uff5a\001\002\000\044\003\u013f" +
    "\016\uff5a\022\uff5a\031\uff45\034\uff5a\035\uff5a\040\uff5a\041" +
    "\uff5a\045\uff5a\051\uff5a\071\uff5a\106\uff5a\140\uff5a\143\uff5a" +
    "\144\uff5a\152\uff5a\156\uff5a\001\002\000\040\005\065\047" +
    "\074\050\056\051\100\113\055\117\054\120\067\143\034" +
    "\144\045\152\023\153\073\154\071\155\076\156\024\157" +
    "\057\001\002\000\004\101\u0198\001\002\000\042\003\ufffc" +
    "\016\ufffc\022\ufffc\034\ufffc\035\ufffc\040\ufffc\041\ufffc\045" +
    "\ufffc\051\ufffc\071\ufffc\106\ufffc\140\ufffc\143\ufffc\144\ufffc" +
    "\152\ufffc\156\ufffc\001\002\000\042\003\u013f\016\uff5a\022" +
    "\uff5a\034\uff5a\035\uff5a\040\uff5a\041\uff5a\045\uff5a\051\uff5a" +
    "\071\uff5a\106\uff5a\140\uff5a\143\uff5a\144\uff5a\152\uff5a\156" +
    "\uff5a\001\002\000\050\003\u013f\016\uff5a\022\uff5a\027\uff47" +
    "\030\uff47\031\uff47\034\uff5a\035\uff5a\040\uff5a\041\uff5a\045" +
    "\uff5a\051\uff5a\071\uff5a\106\uff5a\140\uff5a\143\uff5a\144\uff5a" +
    "\152\uff5a\156\uff5a\001\002\000\050\003\uff2f\016\uff2f\022" +
    "\uff2f\027\uff2f\030\uff2f\031\uff2f\034\uff2f\035\uff2f\040\uff2f" +
    "\041\uff2f\045\uff2f\051\uff2f\071\uff2f\106\uff2f\140\uff2f\143" +
    "\uff2f\144\uff2f\152\uff2f\156\uff2f\001\002\000\004\124\u019d" +
    "\001\002\000\050\003\uff2e\016\uff2e\022\uff2e\027\uff2e\030" +
    "\uff2e\031\uff2e\034\uff2e\035\uff2e\040\uff2e\041\uff2e\045\uff2e" +
    "\051\uff2e\071\uff2e\106\uff2e\140\uff2e\143\uff2e\144\uff2e\152" +
    "\uff2e\156\uff2e\001\002\000\040\005\065\047\074\050\056" +
    "\051\100\113\055\117\054\120\067\143\034\144\045\152" +
    "\023\153\073\154\071\155\076\156\024\157\057\001\002" +
    "\000\004\045\uff3b\001\002\000\010\113\105\122\102\124" +
    "\u01a1\001\002\000\050\003\uff2d\016\uff2d\022\uff2d\027\uff2d" +
    "\030\uff2d\031\uff2d\034\uff2d\035\uff2d\040\uff2d\041\uff2d\045" +
    "\uff2d\051\uff2d\071\uff2d\106\uff2d\140\uff2d\143\uff2d\144\uff2d" +
    "\152\uff2d\156\uff2d\001\002\000\014\016\uff36\022\u015b\035" +
    "\u0157\045\uff3e\106\u0147\001\002\000\004\045\ufffc\001\002" +
    "\000\004\016\u01a5\001\002\000\042\003\uff38\016\uff38\022" +
    "\uff38\034\uff38\035\uff38\040\uff38\041\uff38\045\uff38\051\uff38" +
    "\071\uff38\106\uff38\140\uff38\143\uff38\144\uff38\152\uff38\156" +
    "\uff38\001\002\000\042\003\u013f\016\uff5a\022\uff5a\034\uff5a" +
    "\035\uff5a\040\uff5a\041\uff5a\045\uff5a\051\uff5a\071\uff5a\106" +
    "\uff5a\140\uff5a\143\uff5a\144\uff5a\152\uff5a\156\uff5a\001\002" +
    "\000\044\003\u013f\016\uff5a\022\uff5a\031\u01a8\034\uff5a\035" +
    "\uff5a\040\uff5a\041\uff5a\045\uff5a\051\uff5a\071\uff5a\106\uff5a" +
    "\140\uff5a\143\uff5a\144\uff5a\152\uff5a\156\uff5a\001\002\000" +
    "\004\152\023\001\002\000\004\124\u01aa\001\002\000\050" +
    "\003\uff37\016\uff37\022\uff37\027\uff37\030\uff37\031\uff37\034" +
    "\uff37\035\uff37\040\uff37\041\uff37\045\uff37\051\uff37\071\uff37" +
    "\106\uff37\140\uff37\143\uff37\144\uff37\152\uff37\156\uff37\001" +
    "\002\000\004\045\u0175\001\002\000\004\152\023\001\002" +
    "\000\004\124\u01ae\001\002\000\050\003\uff41\016\uff41\022" +
    "\uff41\027\uff41\030\uff41\031\uff41\034\uff41\035\uff41\040\uff41" +
    "\041\uff41\045\uff41\051\uff41\071\uff41\106\uff41\140\uff41\143" +
    "\uff41\144\uff41\152\uff41\156\uff41\001\002\000\012\105\uff32" +
    "\113\105\122\102\124\uff32\001\002\000\006\105\u01b1\124" +
    "\uff31\001\002\000\040\005\065\047\074\050\056\051\100" +
    "\113\055\117\054\120\067\143\034\144\045\152\023\153" +
    "\073\154\071\155\076\156\024\157\057\001\002\000\004" +
    "\124\u01b3\001\002\000\050\003\uff34\016\uff34\022\uff34\027" +
    "\uff34\030\uff34\031\uff34\034\uff34\035\uff34\040\uff34\041\uff34" +
    "\045\uff34\051\uff34\071\uff34\106\uff34\140\uff34\143\uff34\144" +
    "\uff34\152\uff34\156\uff34\001\002\000\004\124\uff30\001\002" +
    "\000\010\124\uff14\152\023\156\024\001\002\000\004\124" +
    "\uff13\001\002\000\004\124\u01b8\001\002\000\022\002\uff16" +
    "\003\uff16\016\uff16\036\uff16\061\uff16\075\uff16\102\uff16\152" +
    "\uff16\001\002\000\022\002\ufffd\003\ufffd\016\ufffd\036\ufffd" +
    "\061\ufffd\075\ufffd\102\ufffd\152\ufffd\001\002\000\022\002" +
    "\uff15\003\uff15\016\uff15\036\uff15\061\uff15\075\uff15\102\uff15" +
    "\152\uff15\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u01b8\000\022\002\012\135\011\136\014\137\004\147" +
    "\003\154\006\155\010\156\015\001\001\000\002\001\001" +
    "\000\006\053\341\054\342\001\001\000\004\011\334\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\135\011" +
    "\136\014\137\004\147\003\156\333\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\011\020\140\017\141\021" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\142\024\143\026\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\012\011\302\012\304\144\301\145\303" +
    "\001\001\000\002\001\001\000\024\007\040\010\043\011" +
    "\041\025\035\026\030\056\031\057\036\141\042\152\037" +
    "\001\001\000\002\001\001\000\014\027\142\031\144\032" +
    "\050\034\051\153\102\001\001\000\002\001\001\000\004" +
    "\153\300\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\027\276\001\001\000" +
    "\004\153\274\001\001\000\010\031\046\032\050\034\051" +
    "\001\001\000\002\001\001\000\040\011\041\056\100\057" +
    "\036\060\071\061\060\074\272\075\067\076\062\077\061" +
    "\100\065\103\076\105\074\106\057\141\042\152\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\040\011\041" +
    "\056\100\057\036\060\071\061\060\074\063\075\067\076" +
    "\062\077\061\100\065\103\076\105\074\106\057\141\042" +
    "\152\037\001\001\000\002\001\001\000\070\011\041\030" +
    "\214\050\217\051\213\056\215\057\036\060\071\061\060" +
    "\062\212\063\220\064\270\065\115\066\106\067\116\070" +
    "\105\071\113\072\110\074\222\075\067\076\062\077\061" +
    "\100\065\103\076\105\074\106\057\141\042\152\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\104\256\001" +
    "\001\000\006\027\267\033\266\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\102\252\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\014\011\041\056\263\057\036\141\042\152\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\034\011\041" +
    "\056\100\057\036\060\071\061\060\075\247\076\062\077" +
    "\061\100\065\105\074\106\057\141\042\152\037\001\001" +
    "\000\002\001\001\000\004\153\102\001\001\000\006\011" +
    "\245\141\246\001\001\000\002\001\001\000\004\061\210" +
    "\001\001\000\062\011\107\013\112\014\117\056\100\057" +
    "\036\060\071\061\060\064\111\065\115\066\106\067\116" +
    "\070\105\071\113\072\110\074\120\075\067\076\062\077" +
    "\061\100\065\103\076\105\074\106\057\141\042\152\037" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\073\125\101\123" +
    "\001\001\000\002\001\001\000\002\001\001\000\040\011" +
    "\041\056\100\057\036\060\071\061\060\074\146\075\067" +
    "\076\062\077\061\100\065\103\076\105\074\106\057\141" +
    "\042\152\037\001\001\000\002\001\001\000\052\007\040" +
    "\010\043\011\041\025\136\026\030\030\134\056\135\057" +
    "\036\060\071\061\060\074\137\075\067\076\062\077\061" +
    "\100\065\103\076\105\074\106\057\141\042\152\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\014\027\142\031\144\032\050\034\051" +
    "\153\102\001\001\000\002\001\001\000\002\001\001\000" +
    "\040\011\041\056\100\057\036\060\071\061\060\074\141" +
    "\075\067\076\062\077\061\100\065\103\076\105\074\106" +
    "\057\141\042\152\037\001\001\000\002\001\001\000\002" +
    "\001\001\000\042\011\041\030\145\056\100\057\036\060" +
    "\071\061\060\074\137\075\067\076\062\077\061\100\065" +
    "\103\076\105\074\106\057\141\042\152\037\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\042" +
    "\011\041\056\100\057\036\060\071\061\060\072\150\074" +
    "\120\075\067\076\062\077\061\100\065\103\076\105\074" +
    "\106\057\141\042\152\037\001\001\000\002\001\001\000" +
    "\004\004\152\001\001\000\042\011\041\056\100\057\036" +
    "\060\071\061\060\072\153\074\120\075\067\076\062\077" +
    "\061\100\065\103\076\105\074\106\057\141\042\152\037" +
    "\001\001\000\002\001\001\000\004\004\155\001\001\000" +
    "\042\011\041\056\100\057\036\060\071\061\060\072\156" +
    "\074\120\075\067\076\062\077\061\100\065\103\076\105" +
    "\074\106\057\141\042\152\037\001\001\000\002\001\001" +
    "\000\060\011\107\014\161\056\100\057\036\060\071\061" +
    "\060\064\111\065\115\066\106\067\116\070\105\071\113" +
    "\072\110\074\120\075\067\076\062\077\061\100\065\103" +
    "\076\105\074\106\057\141\042\152\037\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\004\176\001\001\000" +
    "\004\004\174\001\001\000\004\004\172\001\001\000\042" +
    "\011\041\056\100\057\036\060\071\061\060\072\171\074" +
    "\120\075\067\076\062\077\061\100\065\103\076\105\074" +
    "\106\057\141\042\152\037\001\001\000\004\004\167\001" +
    "\001\000\042\011\041\056\100\057\036\060\071\061\060" +
    "\072\170\074\120\075\067\076\062\077\061\100\065\103" +
    "\076\105\074\106\057\141\042\152\037\001\001\000\002" +
    "\001\001\000\002\001\001\000\042\011\041\056\100\057" +
    "\036\060\071\061\060\072\173\074\120\075\067\076\062" +
    "\077\061\100\065\103\076\105\074\106\057\141\042\152" +
    "\037\001\001\000\002\001\001\000\042\011\041\056\100" +
    "\057\036\060\071\061\060\072\175\074\120\075\067\076" +
    "\062\077\061\100\065\103\076\105\074\106\057\141\042" +
    "\152\037\001\001\000\002\001\001\000\042\011\041\056" +
    "\100\057\036\060\071\061\060\072\177\074\120\075\067" +
    "\076\062\077\061\100\065\103\076\105\074\106\057\141" +
    "\042\152\037\001\001\000\002\001\001\000\056\011\041" +
    "\056\100\057\036\060\071\061\060\064\201\065\115\066" +
    "\106\067\116\070\105\071\113\072\110\074\120\075\067" +
    "\076\062\077\061\100\065\103\076\105\074\106\057\141" +
    "\042\152\037\001\001\000\002\001\001\000\004\004\203" +
    "\001\001\000\042\011\041\056\100\057\036\060\071\061" +
    "\060\072\204\074\120\075\067\076\062\077\061\100\065" +
    "\103\076\105\074\106\057\141\042\152\037\001\001\000" +
    "\002\001\001\000\004\004\206\001\001\000\042\011\041" +
    "\056\100\057\036\060\071\061\060\072\207\074\120\075" +
    "\067\076\062\077\061\100\065\103\076\105\074\106\057" +
    "\141\042\152\037\001\001\000\002\001\001\000\002\001" +
    "\001\000\070\011\041\030\214\050\217\051\213\056\215" +
    "\057\036\060\071\061\060\062\212\063\220\064\216\065" +
    "\115\066\106\067\116\070\105\071\113\072\110\074\222" +
    "\075\067\076\062\077\061\100\065\103\076\105\074\106" +
    "\057\141\042\152\037\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\027\235\153\102\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\073\125\101\123\001\001\000" +
    "\066\011\041\030\214\050\217\051\224\056\215\057\036" +
    "\060\071\061\060\063\226\064\225\065\115\066\106\067" +
    "\116\070\105\071\113\072\110\074\222\075\067\076\062" +
    "\077\061\100\065\103\076\105\074\106\057\141\042\152" +
    "\037\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\056\011\041\056\100\057\036\060\071\061" +
    "\060\064\233\065\115\066\106\067\116\070\105\071\113" +
    "\072\110\074\120\075\067\076\062\077\061\100\065\103" +
    "\076\105\074\106\057\141\042\152\037\001\001\000\044" +
    "\011\041\030\214\050\231\056\215\057\036\060\071\061" +
    "\060\074\232\075\067\076\062\077\061\100\065\103\076" +
    "\105\074\106\057\141\042\152\037\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\056\011\041\056\100\057\036\060" +
    "\071\061\060\064\237\065\115\066\106\067\116\070\105" +
    "\071\113\072\110\074\120\075\067\076\062\077\061\100" +
    "\065\103\076\105\074\106\057\141\042\152\037\001\001" +
    "\000\002\001\001\000\002\001\001\000\066\011\041\030" +
    "\214\050\217\051\224\056\215\057\036\060\071\061\060" +
    "\063\243\064\225\065\115\066\106\067\116\070\105\071" +
    "\113\072\110\074\222\075\067\076\062\077\061\100\065" +
    "\103\076\105\074\106\057\141\042\152\037\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\102\252\001\001\000" +
    "\002\001\001\000\002\001\001\000\032\011\041\056\100" +
    "\057\036\060\071\061\060\076\254\077\061\100\065\105" +
    "\074\106\057\141\042\152\037\001\001\000\002\001\001" +
    "\000\004\104\256\001\001\000\002\001\001\000\030\011" +
    "\041\056\100\057\036\060\071\061\060\077\262\100\065" +
    "\105\074\106\057\141\042\152\037\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\153\102\001\001\000\026\011\041\056\100\057" +
    "\036\060\071\061\060\100\265\105\074\106\057\141\042" +
    "\152\037\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\027\267\033\273\001\001\000\002\001\001\000\002\001" +
    "\001\000\062\011\107\013\112\014\117\056\100\057\036" +
    "\060\071\061\060\064\111\065\115\066\106\067\116\070" +
    "\105\071\113\072\110\074\120\075\067\076\062\077\061" +
    "\100\065\103\076\105\074\106\057\141\042\152\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\173\327\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\011\317\001\001\000\004" +
    "\146\311\001\001\000\002\001\001\000\002\001\001\000" +
    "\024\007\040\010\043\011\041\025\312\026\030\056\031" +
    "\057\036\141\042\152\037\001\001\000\004\017\314\001" +
    "\001\000\056\011\041\056\100\057\036\060\071\061\060" +
    "\064\315\065\115\066\106\067\116\070\105\071\113\072" +
    "\110\074\120\075\067\076\062\077\061\100\065\103\076" +
    "\105\074\106\057\141\042\152\037\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\011\325\001\001\000\004\146\322\001\001\000" +
    "\024\007\040\010\043\011\041\025\323\026\030\056\031" +
    "\057\036\141\042\152\037\001\001\000\004\017\324\001" +
    "\001\000\002\001\001\000\002\001\001\000\010\011\302" +
    "\012\304\145\331\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\142\336\143\337\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\034\011\346\012\355\015\344\016\345\020" +
    "\343\021\353\024\352\052\357\055\350\135\356\136\014" +
    "\137\004\147\360\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\011\u012e" +
    "\001\001\000\002\001\001\000\004\011\373\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\006\363\001\001\000\002\001\001\000\024" +
    "\007\040\010\043\011\041\025\364\026\030\056\031\057" +
    "\036\141\042\152\037\001\001\000\004\017\365\001\001" +
    "\000\002\001\001\000\002\001\001\000\056\011\041\056" +
    "\100\057\036\060\071\061\060\064\370\065\115\066\106" +
    "\067\116\070\105\071\113\072\110\074\120\075\067\076" +
    "\062\077\061\100\065\103\076\105\074\106\057\141\042" +
    "\152\037\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\022\374\043\376\001\001\000\002" +
    "\001\001\000\012\011\u0101\012\u0102\044\377\045\u0100\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\024\007\040\010" +
    "\043\011\041\025\u0104\026\030\056\031\057\036\141\042" +
    "\152\037\001\001\000\004\017\u0105\001\001\000\002\001" +
    "\001\000\024\007\040\010\043\011\041\025\u0107\026\030" +
    "\056\031\057\036\141\042\152\037\001\001\000\004\017" +
    "\u0108\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\011\u0101\012\u0102\045\u010b\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\023\u010f\036\u0110\001\001\000\004" +
    "\160\u0112\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\037\u0114\040\u0113\001\001\000\014" +
    "\011\u0101\012\u0102\042\u011e\045\u011c\162\u011b\001\001\000" +
    "\004\161\u0118\001\001\000\004\163\u0116\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\041\u0122\046\u0121\001\001" +
    "\000\004\164\u011f\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\011\041\056\u0124\057\036\141" +
    "\042\152\037\001\001\000\004\153\102\001\001\000\004" +
    "\047\u0126\001\001\000\002\001\001\000\046\011\041\030" +
    "\214\050\217\051\u012b\056\215\057\036\060\071\061\060" +
    "\074\232\075\067\076\062\077\061\100\065\103\076\105" +
    "\074\106\057\141\042\152\037\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\037\u012d\040\u0113\001\001\000\002\001\001\000\002" +
    "\001\001\000\024\007\040\010\043\011\041\025\u0130\026" +
    "\030\056\031\057\036\141\042\152\037\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\006\u0134\001\001\000" +
    "\002\001\001\000\024\007\040\010\043\011\041\025\u0135" +
    "\026\030\056\031\057\036\141\042\152\037\001\001\000" +
    "\004\017\u0136\001\001\000\002\001\001\000\002\001\001" +
    "\000\056\011\041\056\100\057\036\060\071\061\060\064" +
    "\u0139\065\115\066\106\067\116\070\105\071\113\072\110" +
    "\074\120\075\067\076\062\077\061\100\065\103\076\105" +
    "\074\106\057\141\042\152\037\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\174\u013c\001\001\000\010\107" +
    "\u013d\110\u0140\111\u013f\001\001\000\006\110\u0177\111\u013f" +
    "\001\001\000\002\001\001\000\054\011\u0143\056\u015b\057" +
    "\036\105\u0155\112\u0159\113\u014b\114\u014c\115\u0147\116\u014a" +
    "\117\u0144\123\u014f\125\u0151\126\u014d\127\u0150\130\u0154\133" +
    "\u0158\134\u0152\141\042\151\u014e\152\037\157\u0142\001\001" +
    "\000\002\001\001\000\016\011\041\056\u01ae\057\036\131" +
    "\u01af\141\042\152\037\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\014\011\041\056\u019f\057" +
    "\036\141\042\152\037\001\001\000\004\004\u019d\001\001" +
    "\000\002\001\001\000\056\011\041\056\100\057\036\060" +
    "\071\061\060\064\u019b\065\115\066\106\067\116\070\105" +
    "\071\113\072\110\074\120\075\067\076\062\077\061\100" +
    "\065\103\076\105\074\106\057\141\042\152\037\001\001" +
    "\000\060\011\041\056\100\057\036\060\071\061\060\064" +
    "\u0183\065\115\066\106\067\116\070\105\071\113\072\110" +
    "\074\120\075\067\076\062\077\061\100\065\103\076\105" +
    "\074\106\057\122\u0182\141\042\152\037\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\004\u0172\001\001\000\002\001\001\000\004\011" +
    "\u0170\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\011\u0162\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\053\u0160\054\342\001\001\000\004" +
    "\153\102\001\001\000\056\011\041\056\100\057\036\060" +
    "\071\061\060\064\u015e\065\115\066\106\067\116\070\105" +
    "\071\113\072\110\074\120\075\067\076\062\077\061\100" +
    "\065\103\076\105\074\106\057\141\042\152\037\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\046" +
    "\010\u0167\011\041\030\u0164\035\u0169\056\u0166\057\036\060" +
    "\071\061\060\074\137\075\067\076\062\077\061\100\065" +
    "\103\076\105\074\106\057\141\042\152\037\001\001\000" +
    "\002\001\001\000\046\010\u0167\011\041\030\u0164\035\u016d" +
    "\056\u0166\057\036\060\071\061\060\074\137\075\067\076" +
    "\062\077\061\100\065\103\076\105\074\106\057\141\042" +
    "\152\037\001\001\000\010\027\267\033\u016c\153\102\001" +
    "\001\000\006\027\267\033\u016b\001\001\000\002\001\001" +
    "\000\004\004\u016a\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\004\u016e\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\124\u0173\001\001\000\002\001\001\000\004" +
    "\170\u0175\001\001\000\010\107\u0176\110\u0140\111\u013f\001" +
    "\001\000\006\110\u0177\111\u013f\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\167\u017b\001" +
    "\001\000\004\003\u017c\001\001\000\002\001\001\000\004" +
    "\171\u017e\001\001\000\010\107\u017f\110\u0140\111\u013f\001" +
    "\001\000\006\110\u0177\111\u013f\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\165\u0184\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\166\u0186\001\001\000\004" +
    "\004\u0187\001\001\000\010\107\u0188\110\u0140\111\u013f\001" +
    "\001\000\010\005\u0189\110\u0177\111\u013f\001\001\000\004" +
    "\004\u018a\001\001\000\004\120\u018b\001\001\000\004\005" +
    "\u018c\001\001\000\006\004\u018d\121\u018f\001\001\000\002" +
    "\001\001\000\004\004\u0193\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\107\u0194\110\u0140\111\u013f\001\001\000\006\110\u0177\111" +
    "\u013f\001\001\000\060\011\041\056\100\057\036\060\071" +
    "\061\060\064\u0183\065\115\066\106\067\116\070\105\071" +
    "\113\072\110\074\120\075\067\076\062\077\061\100\065" +
    "\103\076\105\074\106\057\122\u0196\141\042\152\037\001" +
    "\001\000\002\001\001\000\004\004\u0198\001\001\000\010" +
    "\107\u0199\110\u0140\111\u013f\001\001\000\006\110\u0177\111" +
    "\u013f\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\060\011\041\056\100\057\036\060\071\061" +
    "\060\064\u0183\065\115\066\106\067\116\070\105\071\113" +
    "\072\110\074\120\075\067\076\062\077\061\100\065\103" +
    "\076\105\074\106\057\122\u019e\141\042\152\037\001\001" +
    "\000\002\001\001\000\004\153\102\001\001\000\002\001" +
    "\001\000\006\125\u01a2\127\u01a3\001\001\000\004\004\u01aa" +
    "\001\001\000\002\001\001\000\004\172\u01a5\001\001\000" +
    "\010\107\u01a6\110\u0140\111\u013f\001\001\000\006\110\u0177" +
    "\111\u013f\001\001\000\004\011\u01a8\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\124\u01ab\001\001\000\004" +
    "\011\u01ac\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\153\102\001\001\000\004\132\u01b1\001\001\000\060" +
    "\011\041\056\100\057\036\060\071\061\060\064\u0183\065" +
    "\115\066\106\067\116\070\105\071\113\072\110\074\120" +
    "\075\067\076\062\077\061\100\065\103\076\105\074\106" +
    "\057\122\u01b3\141\042\152\037\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\011\020\140" +
    "\u01b5\141\021\150\u01b6\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\175\u01b8\001\001\000\004\003\u01b9\001" +
    "\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$semantic$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$semantic$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$semantic$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    /**Lista donde se guardan los errores encontrados*/
    public ArrayList<String> errores=new ArrayList<String>();
    /**Mtodo para devolver tanto los errores del parser como los  del lexer, si los hay*/
    public ArrayList<String> getErrores(){
		if(getScanner() instanceof Ada95Lexer){
			errores.addAll(((Ada95Lexer)getScanner()).lexical_errors);		
		}
		return errores;

	}
    /**Mtodo que devuelve las advertencias, hasta esta versin, slo el lexer tiene advertencias...*/
    public ArrayList<String> getAdvertencias(){
	ArrayList<String> warnings=new ArrayList<String>();
	if(getScanner() instanceof Ada95Lexer){
		warnings.addAll(((Ada95Lexer)getScanner()).lexical_warnings);		
	}
	return warnings;
		
    }
    boolean EOFReported=false;
    Stack<String> unClosed=new Stack<String>();
    public String getUnclosed(){return unClosed.pop();}
    public void setUnclosed(String faltante,String abierto, int line, int col){
	String addToUnClosed="'"+faltante+"'"+" faltante para el '"+abierto+"' abierto en lnea "+(line+1)+", columna "+(col+1);
	unClosed.push(addToUnClosed);

    }
    public void emptyLastUnclosed(){String tempUnClosed=unClosed.pop();tempUnClosed=null;}
    	
    /**Guardar los errores en un stringBuffer*/
    //StringBuffer errorMessages=new StringBuffer();
    /* Change the method report_error so it will display the line and
       column of where the error occurred in the input as well as the
       reason for the error which is passed into the method in the
       String 'message'. */
    public void report_error(String message, Object info) {
   	
	/*If the EOF was already reported, just return (to avoid that horrible unexpected EOF...)*/
	if(EOFReported)
		return;
        /* Create a StringBuffer called 'm' with the string 'Error' in it. */
        StringBuffer m = new StringBuffer();
        /* Add to the end of the StringBuffer error message created in
           this method the message that was passed into this method. */
	if(message.equalsIgnoreCase("Syntax error")){
		message="Error Sintctico  ";
	}else if(message.equalsIgnoreCase("Couldn't repair and continue parse")){
		message="Error ";
	}	
        m.append(message);
   
        /* Check if the information passed to the method is the same
           type as the type java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {
            /* Declare a java_cup.runtime.Symbol object 's' with the
               information in the object info that is being typecasted
               as a java_cup.runtime.Symbol object. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            /* Check if the line number in the input is greater or
               equal to zero. */
            if (s.left >= 0) {                
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(": en lnea "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0) {                   
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", columna "+(s.right+1));
		   //ver si se puede sacar el texto:
		   if(getScanner() instanceof Ada95Lexer){
			m.append("; no se esperaba '"+((Ada95Lexer)getScanner()).getCurrentText()+"'");
		   }
		}
	///guardar el error en la variable de errores:
            }else if(s.toString().equals("#0")){
			if(unClosed.empty()){				
				m.append(": final de archivo inesperado");
			}else{
				m.append(": "+getUnclosed());
				EOFReported=true;
			}

		}

        }
   
   
        /* Print the contents of the StringBuffer 'm', which contains
           an error message, out on a line. */
        //System.err.println(m);
	errores.add(m.toString());
	/*Guardar el error en el buffer, mas un salto de lnea:*/
	//	errorMessages.append(m+"\n");
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);

        //System.exit(1);
    }
 /**La funcin que guarda errores para luego ser impresos por el front-end
*@param line, column la lnea y columna del error/
public void push_error(int line, int column){
	errores.add(new String(String.valueOf(line)+"_"+String.valueOf(column)));
	System.out.println(errores);
}*/


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$semantic$actions {



/**The current symbol table*/
LinkedSymbolTable currentScope = new LinkedSymbolTable();
//pongo cualquier cosa, slo para que ya estn en la st (y no deje declarar otras fn con estos nombres):
boolean neverused=currentScope.put("put", new AdaSymbol(new IntegerType()));
boolean neveruser2=currentScope.put("get", new AdaSymbol(new IntegerType()));
/**Variables globales para el control de los subprogramas*/
ArrayList<Type> returns=new ArrayList<Type>();
int branches=0;
/*Variables para la generacin de cdigo intermedio*/
//las instrucciones
ArrayList<Cuadruplo> cuadruplos=new ArrayList<Cuadruplo>();
public static final int MIPS_TEMPS=9;
//los temporales cf: http://en.wikipedia.org/wiki/MIPS_architecture
boolean[] temps=new boolean[MIPS_TEMPS];
int temp_provisorio=0;
/**Para obtener el siguiente temporal libre*/
public String temp_nuevo(){
	return "t"+String.valueOf(++temp_provisorio);
}

/**Ir imprimiendo el cdigo intermedio al generarlo*/
public boolean DEBUG=true;
/*Para agregar cudruplos a la lista. Slo generar el cudruplo si no hay errores.*/
public void gen(Object op, Object arg1, Object arg2, Object res){
	//si hay errores y no estamos debugueando, ni siquiera molestarse en seguir:
	if(!DEBUG && parser.errores.size()>0)
		return;
	/*castear a string*/
	String o=op.toString();
	String a1=arg1.toString();
	String a2=arg2.toString();
	String r=res.toString();
	//pasar los argumentos a lowercase, para no tener problemas luego con la st.
	a1=a1.toLowerCase();
	a2=a2.toLowerCase();
	Cuadruplo quad=new Cuadruplo(o, a1, a2, r);
	cuadruplos.add(quad);	
	if(DEBUG){
		System.out.println((cuadruplos.size()-1)+"    "+quad.toString());
	}	
}

/**Funcin que devuelve el String que representa a un branch de cdigo intermedio*/
public String getIf(Object operador){
	String o=operador.toString();
	return "if_"+o;
}

/**Convierte una literal booleana en un nmero*/
public Integer getNumeric(Boolean val){
	int rv= (val.booleanValue()) ? 1 : 0;
        return new Integer(rv);
}
/**Devuelve la lista de saltos de un valor booleano*/
public BackPatchResult getBackPatch(Boolean b){
	BackPatchResult rval=new BackPatchResult();
	if(b.booleanValue()){
		rval.verdadera=new ListaSalto(cuadruplos.size());
		return rval;
	}else{
		rval.falsa=new ListaSalto(cuadruplos.size());
		return rval;
	}
}

/**Dada una lista de saltos completa los correspondientes cudruplos con el salto proveido*/
public void completa(ListaSalto completar, Object con){
	int value=0;
	String salto=con.toString();
	for(Integer index : completar.lista){
		//por cualquier cosa
		value=index.intValue();
		if(value < cuadruplos.size() && value >=0){
			cuadruplos.get(value).arg1=salto;
		}else if(DEBUG){
			System.err.println("Se trat de asignar un salto a un cudruplo invlido; "+
			index+ ". Hay "+cuadruplos.size()+"  cudruplos");
		}
	}
}
 /**Esta funcin chequea que un subprograma que tiene nombre al principio y final tenga exactamente el mismo nombre
   * @param start la palabra del inicio
     @param sline, scolumn el left y right del smbolo start
     @param end la palabra del final
     @param eline, ecolumn el left y right del smbolo end
 */

 public void check_coherence(Object start, int sline, int scolumn, Object end, int eline, int ecolumn){
	 String s=(String)start;
	 String sInfo="inicio: "+s+" ["+String.valueOf(sline+1)+" , "+String.valueOf((scolumn-s.length()))+"]";
	//la funciones pueden no tener el del final:
	 if(end==null){return;}
	 String e=(String)end;
	 String eInfo=" y fin: "+e+" ["+String.valueOf(eline+1)+" , "+String.valueOf(ecolumn+1)+"]";
	 //ver si son lo mismo:
	if(!s.equals(e)){
		//System.err.println("Error sintctico  : el nombre del subprograma debe coincidir entre "+sInfo+eInfo);
		parser.errores.add("Error sintctico  : el nombre del subprograma debe coincidir entre "+sInfo+eInfo);
	}
	

 }
/**Mtodo para comprobar errores semnticos de tipo. Los agrega tambin a la lista de errores. Se vale del mtodo equals de las clases
   que heredan de Type.
   @param expected el tipo esperado
   @param found el tipo encontrado
   @param foundLine, foundColumn, etc la lnea y columna donde se encuentra la declaracin.
*/
public boolean compare_types(Object expected, Object found, int foundLine, int foundColumn){
	Type e=(Type)expected;
	Type f=(Type)found;
	if(! e.equals(f)){
		StringBuffer errorMessage=new StringBuffer();
		errorMessage.append("Se esperaba el tipo "+e.toString());
		errorMessage.append(" Y se encontr "+f.toString());
		errorMessage.append(" En lnea "+String.valueOf(foundLine+1)+", columna "+String.valueOf(foundColumn+1));
		parser.errores.add(errorMessage.toString());
		return false;		
	}
	return true;
}
/**Mtodo para determinar si un smbolo est o no declarado*/
public AdaSymbol findSymbol(Object id, int line, int column){
	AdaSymbol found;
	found=currentScope.get(id);
	if(found == null){
		parser.errores.add(" No se encuentra el smbolo '"+(String)id+"'. En lnea "+(String.valueOf(line+1))+", columna "+String.valueOf(column+1));
		return null;
	}
	return found;
	
}
/*Agrega un error a los errores del parser*/
public void agregarError(String mensaje, int linea, int columna){
	parser.errores.add(mensaje+". En lnea "+String.valueOf(linea+1)+", columna "+String.valueOf(columna+1));
}

public boolean validateBuiltIn(String method, Object val, int line, int col){
	if(method.equalsIgnoreCase("put") || method.equalsIgnoreCase("get")){
	//the value must be an arraylist of Parser Results:
		if(!(val instanceof ArrayList))
			return false;
	//if it is, cast:
		ArrayList<ParserResult> l=(ArrayList<ParserResult>)val;
	//now, check that it has only one parameter:
		if(l.size()!=1){
			agregarError("La funcin '"+method+"' solamente admite 1 parmetro, "+String.valueOf(l.size())+" suministrados", line, col);
			return false;
		}
	//it has, so, check that the type is valid: it must be one of the primitive types:
		return l.get(0).type.isPrimitive();
		
	}	

	
	//invalid method:
	return false;
}


  private final semantic parser;

  /** Constructor */
  CUP$semantic$actions(semantic parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$semantic$do_action(
    int                        CUP$semantic$act_num,
    java_cup.runtime.lr_parser CUP$semantic$parser,
    java.util.Stack            CUP$semantic$stack,
    int                        CUP$semantic$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$semantic$result;

      /* select the action based on the action number */
      switch (CUP$semantic$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 251: // code_statement ::= qualified_expression SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("code_statement",109, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 250: // compilation_unit ::= subprogram_body 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_unit",108, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 249: // compilation_unit ::= subprogram_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_unit",108, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 248: // compilation_list ::= error 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_list",107, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 247: // compilation_list ::= compilation_list compilation_unit 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_list",107, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 246: // compilation_list ::= compilation_unit 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_list",107, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 245: // compilation ::= compilation_list 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation",106, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 244: // actual_parameter_part ::= LEFTPAR argument_list RIGHTPAR 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT=a;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("actual_parameter_part",105, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 243: // function_call ::= GET actual_parameter_part 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//mismos criterios que el put...
						boolean v=validateBuiltIn("GET", p, pleft, pright);
						if(!v){
							RESULT=new ParserResult("get");							
						}else{
							//assume it has only one element:
							ParserResult uP=((ArrayList<ParserResult>)p).get(0);
							RESULT=new ParserResult("get", uP.type);
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("function_call",104, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 242: // function_call ::= PUT actual_parameter_part 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//ver si cumple con: slo un parmetro, el tipo es o String, int, float o boolean
						boolean v=validateBuiltIn("PUT", p, pleft, pright);						
						if(!v){
							RESULT=new ParserResult("put");							
						}else{
							//assume it has only one element:
							ParserResult uP=((ArrayList<ParserResult>)p).get(0);
							RESULT=new ParserResult("put", uP.type);
						}
						
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("function_call",104, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 241: // function_call ::= name actual_parameter_part 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					ParserResult pn=(ParserResult)n;
					AdaSymbol f=findSymbol(pn.value, nleft, nright);
					if(f==null)
						RESULT=new ParserResult(pn.value);
					else{
						if(!(f.type instanceof FunctionType)){
							agregarError("'"+((String)pn.value)+"' no es una funcin", nleft, nright);
							RESULT=new ParserResult(pn.value);
						}else{//la funcin existe: 
						//ver si est llamado con el nmero correcto de parmetros:
							if(!(f.type.getProduct().size()==((ArrayList<ParserResult>)p).size())){
								agregarError("La funcin '"+((String)pn.value)+
								"' recibe "+(f.type.getProduct().size())+" parmetros. "+
								String.valueOf(((ArrayList<ParserResult>)p).size())
								+" suministrados", nleft, nright);
								RESULT=new ParserResult(pn.value);	
							}else{//el nmero de parmetros es correcto, vamos a ver si son iguales:
								int i=0;
								ArrayList<ParserResult> pr=(ArrayList<ParserResult>)p;
								Type found;Type expected;			
								for(;i<f.type.getProduct().size();i++){
									found=pr.get(i).type;
									expected=f.type.getProduct().get(i);		
									if(!expected.equals(found)){
										agregarError("Argumento incorrecto para la funcin '"+((String)pn.value)+"'"+
										" encontrado '"+found.toString()+"', se esperaba '"+expected.toString()+"'",
										nleft, nright);
										break;			
									}
								}//si termina, el tipo de los parmetros es correcto
								if(i==f.type.getProduct().size())
									RESULT=new ParserResult(pn.value, f.type);
								else
									RESULT=new ParserResult(pn.value);
								
							}//el nmero de parmetros es correcto 
								
						}//es una funcin
					}//se encontr el id
					//create a new dummy function to compare it with this.
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("function_call",104, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 240: // function_call ::= name LEFTPAR RIGHTPAR 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
			
						ParserResult pn=(ParserResult)n;
						AdaSymbol f=findSymbol(pn.value, nleft, nright);	
					        if (f==null)
							RESULT=new ParserResult(pn.value);
					  	else{//found, check if the function complies...
						//check if it IS a function:
							if(!(f.type instanceof FunctionType)){
								agregarError("'"+((String)pn.value)+"' no es una funcin", nleft, nright);
								RESULT=new ParserResult(pn.value);
						//check if it is an empty parameter function:
							}else if(!f.type.getProduct().isEmpty()){
								agregarError("La funcin '"+((String)pn.value)+
								"' recibe "+(f.type.getProduct().size())+" parmetros. O suministrados", nleft, nright);
								RESULT=new ParserResult(pn.value);
						//if it is a function with empty parameters, but no return type, is a procedure!
							}else if(((FunctionType)f.type).getRange() == null){
								agregarError("No se puede usar una llamada a procedimiento como operando", nleft, nright);
								RESULT=new ParserResult(pn.value);
						//it IS a function (i.e it HAS return type:)
							}else{
								RESULT=new ParserResult(pn.value, f.type);
							}
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("function_call",104, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 239: // procedure_call ::= name SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("procedure_call",103, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 238: // designator_option ::= designator 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=d;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("designator_option",102, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 237: // designator_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("designator_option",102, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 236: // subprogram_body ::= subprogram_specification_is declarative_part BEGIN NT$12 sequence_of_statements END designator_option SEMICOLON NT$13 placeholder 
            {
              Object RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-9)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-9)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-9)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-7)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		Object designator=(s instanceof ParserResult) ? ((ParserResult)s).value : s;
					check_coherence(designator,sleft, sright, e, eleft, eright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_body",101, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-9)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 235: // NT$13 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-7)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;

					  if(s != null){
						if(s instanceof ParserResult){
							ParserResult ps=(ParserResult)s;
							for(Type r : returns){
								//si es errortype, ya fue reportado un error
								if(!(r instanceof ErrorType))
									compare_types(ps.type,r,sleft, sright);
							}

							//se asume que slo las funciones tienen branches
							if (returns.size() < branches)
								agregarError("Sentencia de retorno faltante para el subprograma '"+((String)ps.value)+"'"
								, sleft, sright);
						}else{//si no es un ParserResult es un procedure:
							if(returns.size()>0)	
								agregarError("Un procedimiento no puede retornar un valor"+
								" (En el procedimiento '"+((String)s)+"') ", sleft, sright);
						}
					  }
					  //resetear las cosas:
					  currentScope=currentScope.getAncestor();
					  returns=new ArrayList<Type>();
					  branches=0;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$13",123, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 234: // NT$12 ::= 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
Object designator=(s instanceof ParserResult) ? ((ParserResult)s).value : s;
					parser.setUnclosed((" end "+((String)designator)+";"), "begin",bleft, bright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$12",122, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 233: // mode ::= IN OUT 
            {
              Object RESULT =null;
		RESULT="INOUT";
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("mode",100, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 232: // mode ::= OUT 
            {
              Object RESULT =null;
		RESULT="OUT";
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("mode",100, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 231: // mode ::= IN 
            {
              Object RESULT =null;
		RESULT="IN";
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("mode",100, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 230: // mode ::= 
            {
              Object RESULT =null;
		RESULT="IN";
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("mode",100, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 229: // parameter_declaration ::= identifier_list COLON mode subtype_indication initialization_option 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					
					ParserResult ps=(ParserResult)s;
                                	//if the type is null, there was an error down the tree (and is already reported)
	                                if (ps.type != null){
					ArrayList<String> il=(ArrayList<String>)l;
					ArrayList<ParserResult> r=new ArrayList<ParserResult>();
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
							String nombre="";
							String mode=(String)m;
							if(o != null){
								ParserResult po=(ParserResult)o;
								boolean compare=compare_types(ps.type, po.type, oleft, oright);
								//Type tipo=compare ? ps.type : new ErrorType(ps.type);
								Type tipo=ps.type;
								for(String id :il){									
									nombre=(mode.equalsIgnoreCase("in")) ? id+"$constant" : id;
									r.add(new ParserResult(nombre, tipo));
								}
								RESULT=r;
							}else{//there's no initialization expression:
								for(String id: il){
									nombre=(mode.equalsIgnoreCase("in")) ? id+"$constant" : id;
									r.add(new ParserResult(nombre, ps.type));
								}
								RESULT=r;
							}
						}else{
							for(String id: il)
								r.add(new ParserResult(id, null, null));
							RESULT=r;
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
						}
                	                }else{
						RESULT=null;
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("parameter_declaration",99, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 228: // parameter_declaration ::= identifier COLON mode subtype_indication initialization_option 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					ParserResult ps=(ParserResult)s;
					String mode=(String)m;
                                	//if the type is null, there was an error down the tree (and is already reported)
	                                if (ps.type != null){
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
							String nombre=(mode.equalsIgnoreCase("in")) ? ((String)i)+"$constant" : (String)i;
							if(o != null){
								ParserResult po=(ParserResult)o;
								boolean compare=compare_types(ps.type, po.type, oleft, oright);
								//Type tipo=compare ? ps.type : new ErrorType(ps.type);
								Type tipo=ps.type;
								ParserResult r=new ParserResult(nombre, tipo);
								RESULT=r;
							}else{//there's no initialization expression:
								RESULT=new ParserResult(nombre, ps.type);
							}
						}else{
							RESULT=new ParserResult(i, null, null);
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);							     }
                	                }else{
						RESULT=null;
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("parameter_declaration",99, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 227: // parameter_declaration_list ::= parameter_declaration_list SEMICOLON parameter_declaration 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(l != null){
						ArrayList<ParserResult> ll=(ArrayList<ParserResult>)l;
						//puede venir un solo elemento o una lista:
						if(d != null){
							if(!(d instanceof ArrayList)){
								ll.add((ParserResult)d);
							}else{
								ll.addAll((ArrayList<ParserResult>)d);
							}
						}
						RESULT=ll;
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("parameter_declaration_list",98, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // parameter_declaration_list ::= parameter_declaration 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(d != null){
						ArrayList<ParserResult> r=new ArrayList<ParserResult>();
					if (!(d instanceof ArrayList)){
						//asumimos que, si no es una lista, es un parser result
						r.add((ParserResult)d);
						RESULT=r;
					}else{
						RESULT=r;
					}
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("parameter_declaration_list",98, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // formal_part_option ::= formal_part 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=f;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("formal_part_option",97, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // formal_part_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("formal_part_option",97, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // formal_part ::= LEFTPAR parameter_declaration_list NT$11 RIGHTPAR 
            {
              Object RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("formal_part",96, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // NT$11 ::= 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
RESULT=l;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$11",121, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // operator_symbol ::= STRING_LITERAL 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(s, new StringType(((String)s).length()));
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("operator_symbol",95, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // designator ::= operator_symbol 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=o;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("designator",94, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // designator ::= identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=i;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("designator",94, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // subprogram_specification_is ::= FUNCTION designator formal_part_option RETURN subtype_indication IS 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					//es una funcin, as que al menos espera una branch:
					branches=1;
					ParserResult ps=(ParserResult)s;
					if(ps.type != null){
					if(f != null){
						
						ArrayList<ParserResult> fl=(ArrayList<ParserResult>)f;
						ArrayList<Type> ft=new ArrayList<Type>();
						for (ParserResult p:fl)
							ft.add(p.type);							
						if(ps.type != null){
							if(!currentScope.put(i, new AdaSymbol(new FunctionType(ps.type, ft)))){
								agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
							}else{
								currentScope=new LinkedSymbolTable(currentScope);
								String nombre="";
								boolean cons=false;
								for(ParserResult p: fl){
									nombre=((String)p.value).split("\\$")[0];
									cons=((String)p.value).contains("$constant");
									//las funciones slo pueden tener parmetros de tipo in:
									if(!cons){
										agregarError("Las funciones slo pueden tener parmetros de modo in",
										fleft, fright );
										cons=true;
									}
									if(!currentScope.put(nombre, new AdaSymbol(p.type, cons))){
										agregarError("'"+nombre+"' ya ha sido declarado", fleft, fright);
									}
								}
							}
						}
						
					}else{
						if(!currentScope.put(i, new AdaSymbol(new FunctionType(ps.type))))
							agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
						else{
							currentScope=new LinkedSymbolTable(currentScope);
						}
						
					}
					
 					RESULT=new ParserResult(i,ps.type);
					}else{
					 RESULT=i;
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification_is",93, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // subprogram_specification_is ::= PROCEDURE identifier formal_part IS 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					  //formal part es una lista de parser results:
					  if( f!= null){											  	
						ArrayList<ParserResult> fl=(ArrayList<ParserResult>)f;
						ArrayList<Type> ft=new ArrayList<Type>();
						for (ParserResult p:fl)
							ft.add(p.type);												                                             if(!currentScope.put(i, new AdaSymbol(new FunctionType(ft)))){
							agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
						}else{
							currentScope=new LinkedSymbolTable(currentScope);
							String nombre="";
							boolean cons=false;
							for(ParserResult p: fl){
								nombre=((String)p.value).split("\\$")[0];
								cons=((String)p.value).contains("$constant");
								if(!currentScope.put(nombre, new AdaSymbol(p.type, cons))){
									agregarError("'"+nombre+"' ya ha sido declarado", fleft, fright);
								}
							}
						}
					  }
					
					RESULT=i;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification_is",93, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // subprogram_specification_is ::= PROCEDURE identifier IS 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					if(!currentScope.put(i, new AdaSymbol(new FunctionType()))){
						agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
					}else{
					  currentScope=new LinkedSymbolTable(currentScope);
					}
					  RESULT=i;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification_is",93, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // subprogram_specification ::= FUNCTION designator formal_part_option RETURN subtype_indication 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
						ParserResult ps=(ParserResult)s;
						if(f != null){//si la formal part est correcta:
							/*Si los nombres de los parmetros me importaran: */
							//ArrayList<ParserResult> pf=(ArrayList<ParserResult>)f;
							//slo me importan los types?
							//LinkedSymbolTable ft=(LinkedSymbolTable)f;	 
							ArrayList<ParserResult> fl=(ArrayList<ParserResult>)f;
							ArrayList<Type> ft=new ArrayList<Type>();
							for (ParserResult p:fl)
								ft.add(p.type);							
							if(ps.type != null){
								if(!currentScope.put(d, new AdaSymbol(new FunctionType(ps.type, ft))))
									agregarError("'"+((String)d)+"' ya ha sido declarado.", dleft, dright);
							}
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification",92, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // subprogram_specification ::= PROCEDURE identifier formal_part_option 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
						if(f != null){
							ArrayList<ParserResult> fl=(ArrayList<ParserResult>)f;
							ArrayList<Type> ft=new ArrayList<Type>();
							for (ParserResult p:fl)
								ft.add(p.type);
							if(!currentScope.put(i, new AdaSymbol(new FunctionType(ft))))
								agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification",92, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // subprogram_declaration ::= subprogram_specification SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_declaration",91, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // goto_statement ::= GOTO name SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("goto_statement",90, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // return_statement ::= RETURN expression SEMICOLON 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("return_statement",89, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // return_statement ::= RETURN SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("return_statement",89, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // when_option ::= WHEN condition 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType))
							agregarError("Se esperaba un tipo booleano y se encontr"+pc.type.toString(), cleft, cright);
					 }
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("when_option",88, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // when_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("when_option",88, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // name_option ::= name 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name_option",87, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // name_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name_option",87, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // exit_statement ::= EXIT name_option when_option SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("exit_statement",86, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // declare_part_option ::= DECLARE declarative_part 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declare_part_option",85, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // declare_part_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declare_part_option",85, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // block ::= identifier COLON declare_part_option BEGIN NT$10 sequence_of_statements END identifier SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-8)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("block",84, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // NT$10 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
parser.setUnclosed((" end "+((String)i)+ ";"), ("begin del bloque "+((String)i)),ileft, iright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$10",120, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // block ::= declare_part_option BEGIN NT$9 sequence_of_statements END SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("block",84, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // NT$9 ::= 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
parser.setUnclosed("end;", "begin del bloque",bleft, bright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$9",119, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // iteration_clause_option ::= WHILE m condition 
            {
              Object RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType)){
							agregarError("Se esperaba un tipo booleano y se encontr"+pc.type.toString(), cleft, cright);
						}else{
							//subir la lista verdadera de la condicin para que la llene el loop y el valor
							// de m para completar lo de las sentencias y generar el goto
							ParserResult res=new ParserResult();
							ParserResult mr=(ParserResult)m;
							res.value=mr.value;
							res.backpatch.falsa=pc.backpatch.falsa;
							res.backpatch.verdadera=pc.backpatch.verdadera;
							RESULT=res;
						}
					 }
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",83, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // iteration_clause_option ::= FOR identifier IN REVERSE discrete_range m 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					currentScope=new LinkedSymbolTable(currentScope); 
					Type tipo=(r != null) ? ((ParserResult)r).type : new IntegerType();
					if(!currentScope.put(i, new AdaSymbol(tipo, true))){
						agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
					}
					//generar la condicin:
					if(r != null){
						ParserResult range=(ParserResult)r;
						Object initial = ((ArrayList<Object>)range.value).get(0);
						Object fin     = ((ArrayList<Object>)range.value).get(1);
						//ac podramos avisar que el rango es nulo
						// identifier := range_initial
						gen(":=", fin, "", i);	
						//las listas verdadera y falsa:
						BackPatchResult b_res=new BackPatchResult(new ListaSalto(cuadruplos.size()),
                                                                                          new ListaSalto(cuadruplos.size()+1));
						//generar las instrucciones:
						gen("if_<=", i, initial, "");
						gen("goto", " ", "", "");
						/*Hier: Generar la etiqueta de inicio, la asignacin y la condicin.*/
						ParserResult mr=(ParserResult)m;
						ArrayList<Object> post=new ArrayList<Object>(2);
						post.add(mr.value);
						post.add(new Cuadruplo("+", i.toString(), "1", i.toString()));
						RESULT=new ParserResult(post, b_res);
					}	
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",83, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // iteration_clause_option ::= FOR identifier IN discrete_range m 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					currentScope=new LinkedSymbolTable(currentScope); 
					//ver si viene algo en el rango:
					Type tipo=(r != null) ? ((ParserResult)r).type : new IntegerType();
					if(!currentScope.put(i, new AdaSymbol(tipo, true))){
						agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);					
					}
					/*
					//avisar si el rango es nulo:
					if(r ==  null)
						agregarError("Advertencia: El rango del ciclo es nulo y no se ejecutar", rleft, rright);
					*/
					if(r != null){
						ParserResult range=(ParserResult)r;
						Object initial = ((ArrayList<Object>)range.value).get(0);
						Object fin     = ((ArrayList<Object>)range.value).get(1);
						//ac podramos avisar que el rango es nulo
						// identifier := range_initial
						gen(":=", initial, "", i);	
						//las listas verdadera y falsa:
						BackPatchResult b_res=new BackPatchResult(new ListaSalto(cuadruplos.size()),
                                                                                          new ListaSalto(cuadruplos.size()+1));
						//generar las instrucciones:
						gen("if_>=", i, fin, "");
						gen("goto", " ", "", "");
						/*Hier: Generar la etiqueta de inicio, la asignacin y la condicin.*/
						ParserResult mr=(ParserResult)m;
						ArrayList<Object> post=new ArrayList<Object>(2);
						post.add(mr.value);
						post.add(new Cuadruplo("+", i.toString(), "1", i.toString()));
						RESULT=new ParserResult(post, b_res);
						
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",83, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // iteration_clause_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",83, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // basic_loop ::= LOOP NT$8 sequence_of_statements END LOOP 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		RESULT=s;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("basic_loop",82, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // NT$8 ::= 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
parser.setUnclosed("end loop;", "loop",lleft,lright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$8",118, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // loop_statement ::= identifier COLON iteration_clause_option m basic_loop identifier SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-6)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int jleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object j = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					String si=(String)i; 
					String sj=(String)j;
					if(!si.equalsIgnoreCase(sj))
						agregarError("Se esperaba 'end loop "+si+"' y se encontr 'end loop "+sj+"'", jleft, jright);
					if(o != null){						
						currentScope=new LinkedSymbolTable(currentScope); 
					  }
					/*la iteration clause ya trae las cosas de la condicin Y el marcador antes de sta*/
						ParserResult iteration=(ParserResult)o;
						ParserResult mr=(ParserResult)m;
						ParserResult sr=(ParserResult)s;						
						completa(iteration.backpatch.verdadera, mr.value);
						/*Aqu hay una disyuntiva, o viene una lista o no, si viene
						una, es porque es un for y hay que generarlo*/
						if(iteration.value instanceof ArrayList){
							ArrayList<Object> post=(ArrayList)iteration.value;
							completa(sr.backpatch.siguiente, cuadruplos.size());
							Cuadruplo step=(Cuadruplo)post.get(1);
							gen(step.operador, step.arg1, step.arg2, step.res);
							//genera un goto adonde est la condicin:
							gen("goto", post.get(0), "", "");
						}else{//no es una lista, si no un simple m
							completa(sr.backpatch.siguiente, iteration.value);	
							gen("goto", iteration.value, "", "");
						}
						ListaSalto siguiente=iteration.backpatch.falsa;
						RESULT=new ParserResult(
							new BackPatchResult(siguiente)
						);				
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("loop_statement",81, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // loop_statement ::= iteration_clause_option m basic_loop SEMICOLON NT$7 placeholder 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		/*la iteration clause ya trae las cosas de la condicin Y el marcador antes de sta*/
						ParserResult iteration=(ParserResult)o;
						ParserResult mr=(ParserResult)m;
						ParserResult sr=(ParserResult)s;
						completa(iteration.backpatch.verdadera, mr.value);
						if(iteration.value instanceof ArrayList){
							ArrayList<Object> post=(ArrayList)iteration.value;
							completa(sr.backpatch.siguiente, cuadruplos.size());
							Cuadruplo step=(Cuadruplo)post.get(1);
							gen(step.operador, step.arg1, step.arg2, step.res);
							//genera un goto adonde est la condicin:
							gen("goto", post.get(0), "", "");
						}else{//no es una lista, si no un simple m
							completa(sr.backpatch.siguiente, iteration.value);	
							gen("goto", iteration.value, "", "");
						}
						ListaSalto siguiente=iteration.backpatch.falsa;
						RESULT=new ParserResult(
							new BackPatchResult(siguiente)
						);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("loop_statement",81, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // NT$7 ::= 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
//se asume que si la iteration_clause existe, se cre una st para sta
					 if(o != null)
						currentScope=currentScope.getAncestor();
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$7",117, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // condition ::= expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("condition",80, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // else_option ::= ELSE m sequence_of_statements 
            {
              Object RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		ParserResult ps=(ParserResult)s;
				  ParserResult mr=(ParserResult)m;
				  RESULT=new ParserResult(mr.value, ps.backpatch);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("else_option",79, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // else_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("else_option",79, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // elsif_list ::= elsif_list n m ELSIF condition THEN m sequence_of_statements 
            {
              Object RESULT =null;
		int elsifleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).left;
		int elsifright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).right;
		Object elsif = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-7)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-6)).value;
		int munoleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int munoright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object muno = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mdosleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mdosright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object mdos = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		 branches++;
					  if(c != null){
						ParserResult pc=(ParserResult)c;
						ParserResult mDosr=(ParserResult)mdos;
						ParserResult sr=(ParserResult)s;						
						ParserResult nr=(ParserResult)n;
						if(!(pc.type instanceof BooleanType))
							agregarError("Una condicin debe ser de un tipo booleano y se encontr "+pc.type.toString(),
						        cleft, cright);
						/*elsif no pudo completar su lista de siguientes, hagmosle el favor*/
						if(elsif != null){
							ParserResult er=(ParserResult)elsif;
							ParserResult mr=(ParserResult)muno;
							completa(er.backpatch.siguiente, mr.value);
						}
					 	completa(pc.backpatch.verdadera, mDosr.value);	
						/*Subimos las que ocupan ser completadas:*/
						RESULT=new ParserResult(new BackPatchResult(
									ListaSalto.fusiona(sr.backpatch.siguiente,
									ListaSalto.fusiona(pc.backpatch.siguiente, nr.backpatch.siguiente))));
					 }
					
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("elsif_list",78, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // elsif_list ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("elsif_list",78, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // if_statement ::= IF condition NT$5 THEN NT$6 m sequence_of_statements n m elsif_list n else_option END IF SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-10)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-14)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-14)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-14)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-13)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-13)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-13)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-9)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-9)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-9)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-8)).value;
		int nunoleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).left;
		int nunoright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).right;
		Object nuno = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-7)).value;
		int mdosleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).left;
		int mdosright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).right;
		Object mdos = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-6)).value;
		int elsifleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int elsifright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object elsif = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int ndosleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int ndosright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object ndos = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int elsleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int elsright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object els = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		
						/*Estn estos casos: que no venga ni elsif ni else.
						Que venga slo else
						Que venga slo elsif*/
						ParserResult m1=(ParserResult)m;
						ParserResult ps=(ParserResult)s;
						ParserResult pc=(ParserResult)c;
						ParserResult pn1=(ParserResult)nuno;
						ParserResult pn2=(ParserResult)ndos;
						ParserResult m2=(ParserResult)mdos;
						ParserResult RetVal=new ParserResult();
						completa(pc.backpatch.verdadera, m1.value);
						RetVal.backpatch.siguiente=ListaSalto.fusiona(ps.backpatch.siguiente, pc.backpatch.falsa);
						if(els != null){
							ParserResult pelse=(ParserResult)els;
							completa(pc.backpatch.falsa, pelse.value);
							RetVal.backpatch.siguiente=ListaSalto.fusiona(ps.backpatch.siguiente,
									           ListaSalto.fusiona(pelse.backpatch.siguiente,
												      pn2.backpatch.siguiente));
							if(elsif != null){
								ParserResult pei=(ParserResult)elsif;
								completa(pc.backpatch.falsa, m2.value);
								completa(pei.backpatch.siguiente, pelse.value);			
							}
						}else if(elsif != null){
							ParserResult pei=(ParserResult)elsif;
							completa(pc.backpatch.falsa, m2.value);
							RetVal.backpatch.siguiente=ListaSalto.fusiona(ps.backpatch.siguiente,
										   ListaSalto.fusiona(pei.backpatch.siguiente,
												      pn2.backpatch.siguiente));
						}
						RESULT=RetVal;
						
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("if_statement",77, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-14)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // NT$6 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
parser.setUnclosed("end if;", "if", ileft, iright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$6",116, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // NT$5 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
 branches++;
					 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType))
							agregarError("Una condicin debe ser de un tipo booleano y se encontr "+pc.type.toString(),
							 cleft, cright);
					 }
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$5",115, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // assignment_statement ::= name ASSIGNMENT expression SEMICOLON 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					if(e != null){
						ParserResult pe=(ParserResult)e;
						ParserResult pn=(ParserResult)n;
						//AdaSymbol gn=currentScope.get(pn.value);
						
						if(pn.type != null){
						//get it:
						AdaSymbol gn=currentScope.get(pn.value);
						//if it is a function, a record or a constant, then it's not eligible:
						if(gn.type instanceof FunctionType)
						agregarError("El lado izquierdo de la asignacin debe ser una variable, no una funcin", nleft, nright);
						else if(gn.type instanceof RecordType)						
						agregarError("El lado izquierdo de la asignacin debe ser una variable, no un registro", nleft, nright);
						else if(gn.constant)
					agregarError("El lado izquierdo de la asignacin debe ser una variable, no un objeto constante", nleft, nright);
						else//si todo sale bien, entonces s comparar:					
						    compare_types(pn.type, pe.type, eleft, eright);
						}
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("assignment_statement",76, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // null_statement ::= NULL SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("null_statement",75, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // label ::= LEFTLABEL identifier RIGHTLABEL 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("label",74, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // compound_statement ::= block 
            {
              Object RESULT =null;
		parser.emptyLastUnclosed();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compound_statement",73, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // compound_statement ::= loop_statement 
            {
              Object RESULT =null;
		parser.emptyLastUnclosed();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compound_statement",73, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // compound_statement ::= if_statement 
            {
              Object RESULT =null;
		parser.emptyLastUnclosed();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compound_statement",73, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // simple_statement ::= code_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // simple_statement ::= procedure_call 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // simple_statement ::= goto_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // simple_statement ::= return_statement 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(e != null){
						ParserResult pe=(ParserResult)e;
						returns.add(pe.type);
					}else{
						returns.add(new ErrorType());
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // simple_statement ::= exit_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // simple_statement ::= assignment_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // simple_statement ::= null_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // label_list ::= label_list label 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("label_list",71, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // label_list ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("label_list",71, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // statement ::= error 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // statement ::= label_list compound_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // statement ::= label_list simple_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // sequence_of_statements ::= sequence_of_statements statement 
            {
              Object RESULT =null;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(q != null)
						RESULT=q;
					else
						RESULT=s;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("sequence_of_statements",69, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // sequence_of_statements ::= statement 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=s;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("sequence_of_statements",69, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // allocator ::= NEW name 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("allocator",68, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // qualified_expression ::= name TICK aggregate 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("qualified_expression",67, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // qualified_expression ::= name TICK LEFTPAR expression RIGHTPAR 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("qualified_expression",67, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // multiplying_operator ::= REM 
            {
              Object RESULT =null;
		RESULT= new ParserResult("rem");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("multiplying_operator",66, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // multiplying_operator ::= MOD 
            {
              Object RESULT =null;
		RESULT= new ParserResult("%");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("multiplying_operator",66, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // multiplying_operator ::= DIVIDE 
            {
              Object RESULT =null;
		RESULT= new ParserResult("/");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("multiplying_operator",66, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // multiplying_operator ::= MULTIPLY 
            {
              Object RESULT =null;
		RESULT= new ParserResult("*");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("multiplying_operator",66, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // unary_operator ::= ABS 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult("abs", new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("unary_operator",65, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // unary_operator ::= NOT 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult("!", new BooleanType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("unary_operator",65, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // unary_operator ::= MINUS 
            {
              Object RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult("-", new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("unary_operator",65, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // unary_operator ::= PLUS 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult("+", new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("unary_operator",65, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // adding_operator ::= CONCATENATE 
            {
              Object RESULT =null;
		RESULT= new ParserResult("&");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("adding_operator",64, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // adding_operator ::= MINUS 
            {
              Object RESULT =null;
		RESULT= new ParserResult("-");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("adding_operator",64, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // adding_operator ::= PLUS 
            {
              Object RESULT =null;
		RESULT=new ParserResult("+");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("adding_operator",64, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // relational_operator ::= LTEQ 
            {
              Object RESULT =null;
		RESULT= new ParserResult("<=");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // relational_operator ::= GTEQ 
            {
              Object RESULT =null;
		RESULT= new ParserResult(">=");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // relational_operator ::= GT 
            {
              Object RESULT =null;
		RESULT= new ParserResult(">");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // relational_operator ::= LT 
            {
              Object RESULT =null;
		RESULT= new ParserResult("<");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // relational_operator ::= INEQUALITY 
            {
              Object RESULT =null;
		RESULT= new ParserResult("/=");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // relational_operator ::= EQUAL 
            {
              Object RESULT =null;
		RESULT= new ParserResult("==");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // primary ::= LEFTPAR expression RIGHTPAR 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // primary ::= qualified_expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // primary ::= allocator 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // primary ::= name 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=n;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // primary ::= aggregate 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // primary ::= literal 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=l;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // factor ::= primary EXPONENTIATE primary 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								String lugar=temp_nuevo();
								gen("**", pr.value, qr.value, lugar);
								RESULT=new ParserResult(lugar, ptipo);
							}
							else {
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numrico y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo numrico y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("factor",61, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // factor ::= primary 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					   ParserResult pr=(ParserResult)p;
					   if(pr.type != null){
						RESULT=pr;						
					   }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("factor",61, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // term ::= term multiplying_operator factor 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if ((p != null) && (q != null)){
							
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult or=(ParserResult)o;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								String lugar=temp_nuevo();
								gen(or.value, pr.value, qr.value, lugar);
								RESULT=new ParserResult(lugar, ptipo);
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numrico y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo numrico y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					}	
					}	
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("term",60, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // term ::= factor 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(f != null){					  
					   ParserResult pr=(ParserResult)f;
					   if(pr.type != null){
						RESULT=pr;						
					   }
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("term",60, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // term_list ::= term_list adding_operator term 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult or=(ParserResult)o;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								String lugar=temp_nuevo();
								gen(or.value, pr.value, qr.value, lugar);
								RESULT=new ParserResult(lugar, ptipo);
							}else {
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numrico y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo numrico y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("term_list",59, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // term_list ::= term 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(t != null){					  
					   ParserResult pr=(ParserResult)t;
					   if(pr.type != null){
						RESULT=pr;						
					   }
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("term_list",59, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // simple_expression ::= unary_operator term_list 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(t != null){
						ParserResult pt=(ParserResult)t;
					if(pt.type != null){						
					 Type ptipo=(pt.type instanceof FunctionType)? (((FunctionType)pt.type).getRange()) : pt.type;
						ParserResult po=(ParserResult)o;
						Type so=(Type)po.type;						
						if(so.isNumeric()){
							if(ptipo.isNumeric()){
							    String lugar=temp_nuevo();
							    gen(po.value, pt.value, "", lugar);
							    RESULT=new ParserResult(lugar, ptipo);
							}else{								
							    agregarError("Se esperaba un tipo numrico y se encontr "+ptipo.toString(), oleft, oright);
							    RESULT=null;
							}	
						}else{//the operator is boolean! (The 'NOT' operator)
						/**Si la term_list es boolean, TIENE que traer su lista de backpatch*/
							if(ptipo instanceof BooleanType){
							    String lugar=temp_nuevo();
							    gen(po.value, pt.value, "", lugar);	
							    if(pt.backpatch != null){
								RESULT=new ParserResult(lugar, ptipo, 
									   new BackPatchResult(pt.backpatch.falsa, pt.backpatch.verdadera));
							    }else{
								RESULT=new ParserResult(lugar, ptipo);
							    }
							}else{
							    agregarError("Se esperaba un tipo booleano y se encontr "+ptipo.toString(), oleft, oright);
							    RESULT=null;
							}
						}						
					}
					}

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_expression",58, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // simple_expression ::= term_list 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(t != null){					  
					   ParserResult pr=(ParserResult)t;
					   if(pr.type != null){
						RESULT=pr;						
					   }
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_expression",58, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // membership_operator ::= NOT IN 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("membership_operator",57, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // membership_operator ::= IN 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("membership_operator",57, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // relation ::= simple_expression membership_operator subtype_indication 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					  if(p != null){
						ParserResult pr=(ParserResult)p;
						ParserResult ps=(ParserResult)s;
						if ((ps.type != null) && (pr.type != null)){
						 	Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
							if(compare_types(ptipo, ps.type, sleft, sright)){
								RESULT=pr;
							}else{
								RESULT=null;
							}						
						}
					  }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relation",56, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // relation ::= simple_expression membership_operator range 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numrico y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo numrico y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
					 
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relation",56, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // relation ::= simple_expression relational_operator simple_expression 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult po=(ParserResult)o;
					 if((pr.type != null) && (qr.type != null)){
					 //si no son null, vienen buenos:
						BackPatchResult res=new BackPatchResult(new ListaSalto(cuadruplos.size()),
											new ListaSalto(cuadruplos.size()+1));
						gen(getIf(po.value), pr.value, qr.value, " ");
						gen("goto", " ", "", "");
						RESULT=new ParserResult(new BooleanType(), res);
						}
						
					 }
				

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relation",56, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // relation ::= simple_expression 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=s;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relation",56, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // orelse_expression ::= orelse_expression OR_ELSE m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult pm=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.falsa, pm.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									ListaSalto.fusiona(pr.backpatch.verdadera, qr.backpatch.verdadera),
									qr.backpatch.falsa
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("orelse_expression",55, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // orelse_expression ::= relation OR_ELSE m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.falsa, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									ListaSalto.fusiona(pr.backpatch.verdadera, qr.backpatch.verdadera),
									qr.backpatch.falsa
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(qtipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
						
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("orelse_expression",55, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // andthen_expression ::= andthen_expression AND_THEN m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.verdadera, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									qr.backpatch.verdadera,	
									ListaSalto.fusiona(pr.backpatch.falsa, qr.backpatch.falsa)
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("andthen_expression",54, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // andthen_expression ::= relation AND_THEN m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
				 	 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.verdadera, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									qr.backpatch.verdadera,	
									ListaSalto.fusiona(pr.backpatch.falsa, qr.backpatch.falsa)
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(qtipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("andthen_expression",54, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // xor_expression ::= xor_expression XOR relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("xor_expression",53, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // xor_expression ::= relation XOR relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("xor_expression",53, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // or_expression ::= or_expression OR m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.falsa, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									ListaSalto.fusiona(pr.backpatch.verdadera, qr.backpatch.verdadera),
									qr.backpatch.falsa
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(qtipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("or_expression",52, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // or_expression ::= relation OR m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							if(compare_types(ptipo,qtipo, qleft, qright)){							
								completa(pr.backpatch.falsa, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									ListaSalto.fusiona(pr.backpatch.verdadera, qr.backpatch.verdadera),
									qr.backpatch.falsa
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(qtipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("or_expression",52, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // and_expression ::= and_expression AND m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.verdadera, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									qr.backpatch.verdadera,	
									ListaSalto.fusiona(pr.backpatch.falsa, qr.backpatch.falsa)
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(qtipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("and_expression",51, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // and_expression ::= relation AND m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.verdadera, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									qr.backpatch.verdadera,	
									ListaSalto.fusiona(pr.backpatch.falsa, qr.backpatch.falsa)
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(qtipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontr "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontr "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("and_expression",51, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // expression ::= orelse_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // expression ::= andthen_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // expression ::= xor_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // expression ::= or_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // expression ::= and_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // expression ::= relation 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // component_association ::= choice_list ARROW expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_association",49, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // component_association ::= expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_association",49, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // component_association_list ::= component_association_list COMMA component_association 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_association_list",48, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // component_association_list ::= component_association COMMA component_association 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_association_list",48, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // aggregate ::= LEFTPAR choice_list ARROW expression RIGHTPAR 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("aggregate",47, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // aggregate ::= LEFTPAR component_association_list RIGHTPAR 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("aggregate",47, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // literal ::= NULL 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT= new ParserResult(n);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // literal ::= BOOLEAN_LITERAL 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT= new ParserResult(getNumeric(b), new BooleanType(), getBackPatch(b));
					  gen("goto", " ", "", "");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // literal ::= CHARACTER_LITERAL 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT= new ParserResult(c, new StringType(1));
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // literal ::= FLOATING_POINT_LITERAL 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Float f = (Float)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT= new ParserResult(f, new FloatType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // literal ::= INTEGER_LITERAL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(i, new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // selected_component ::= name POINT operator_symbol 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("selected_component",45, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // selected_component ::= name POINT ALL 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		
					AdaSymbol f=findSymbol(n, nleft, nright);
					if(f != null)
						RESULT=new ParserResult(n, f.type);
					else
						RESULT=new ParserResult(n);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("selected_component",45, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // selected_component ::= name POINT identifier 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					//the selected component query:
						ParserResult namen=(ParserResult)n;
						String valex=((String)namen.value)+"."+((String)i);
						Type t=null;
					//query for it in the current scope:
						AdaSymbol f=currentScope.get(valex);		
						if (f !=null)//found:
							t=f.type;
						else
							parser.errores.add("No se puede encontrar el componente '"+((String)i)+
							"' para el prefijo '"+((String)namen.value)+ "'. En lnea "+String.valueOf(nleft+1)+
							", columna "+String.valueOf(nright+1));
						RESULT=new ParserResult(valex, t);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("selected_component",45, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // name ::= operator_symbol 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//buscar el nombre en la tabla de smbolos:					  
					  ParserResult pi=(ParserResult)i;
					  //AdaSymbol f=findSymbol(pi.value, ileft, iright);
					  /*Si no lo encuentra, asumamos que es un string normal...*/
					  AdaSymbol f=currentScope.get(pi.value);					  
					  if(f!= null)
						RESULT=new ParserResult(i, f.type);						 
					  else
						//RESULT=new ParserResult(i);
						RESULT=pi;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // name ::= function_call 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=f;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // name ::= selected_component 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=s;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // name ::= identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//buscar el nombre en la tabla de smbolos:
					  AdaSymbol f=findSymbol(i, ileft, iright);
					  if(f!= null)
						RESULT=new ParserResult(i, f.type);						 
					  else
						RESULT=new ParserResult(i);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // declarative_item ::= error SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item",43, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // declarative_item ::= subprogram_body 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item",43, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // declarative_item ::= declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item",43, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // declarative_item_list ::= declarative_item_list declarative_item 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item_list",42, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // declarative_item_list ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item_list",42, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // declarative_part ::= declarative_item_list 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_part",41, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // incomplete_type_declaration ::= TYPE identifier discriminant_part_option SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("incomplete_type_declaration",40, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // choice_list ::= choice_list VERTICAL_LINE choice 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice_list",39, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // choice_list ::= choice 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice_list",39, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // choice ::= range 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice",38, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // choice ::= name range_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice",38, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // choice ::= OTHERS 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice",38, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // choice ::= simple_expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice",38, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // variant_list ::= variant_list WHEN choice_list ARROW component_list 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_list",37, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // variant_list ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_list",37, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // variant_part ::= CASE name IS variant_list END CASE SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_part",36, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // discriminant_declaration ::= identifier_list COLON subtype_indication initialization_option 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					  ParserResult ps=(ParserResult)s;
					  ArrayList<String> il=(ArrayList<String>)l;
					  if(ps.type != null){//si el tipo s fue encontrado:
						ArrayList<ParserResult> r=new ArrayList<ParserResult>();
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
							if(o != null){//ver si el tipo de o coincide con el de s:
								 ParserResult po=(ParserResult)o;
								 boolean compare=compare_types(ps.type, po.type, oleft, oright);
								 //Type tipo=compare ? ps.type : new ErrorType(ps.type);
								 Type tipo=ps.type;
								 for(String id: il){						
									r.add(new ParserResult(id, tipo));					
								 }
								 RESULT=r;
							}else{//no hay inicializacin:
								 for(String id: il){						
									r.add(new ParserResult(id, ps.type));					
								 }
								 RESULT=r;
							}
						}else{
							for(String id:il){
								r.add(new ParserResult(id, null, null));
							}
							RESULT=r;
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
						}
					  }else{
						RESULT=null;
					  }
						
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_declaration",35, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // discriminant_declaration ::= identifier COLON subtype_indication initialization_option 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//ver si el tipo existe. Si existe, ver si coincide con la inicializacin.
					  //si algo malo pasa, devolver null.
					  ParserResult ps=(ParserResult)s;
					  if(ps.type != null){//si el tipo s fue encontrado:
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)) //si el tipo ES un tipo:
							if(o != null){//ver si el tipo de o coincide con el de s:
								 ParserResult po=(ParserResult)o;
								 boolean compare=compare_types(ps.type, po.type, oleft, oright);
								 //Type tipo=compare ? ps.type : new ErrorType(ps.type);
								 Type tipo=ps.type;
								 RESULT=new ParserResult(i, tipo);
							}else{//no hay inicializacin:
								RESULT=new ParserResult(i, ps.type);
							}
						  else{
							RESULT=new ParserResult(i, null, null);
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
						  }
					  }else{//el tipo no fue encontrado
						RESULT=null;
					  }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_declaration",35, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // discriminant_declaration_list ::= discriminant_declaration_list SEMICOLON discriminant_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_declaration_list",34, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // discriminant_declaration_list ::= discriminant_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_declaration_list",34, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // discriminant_part ::= LEFTPAR discriminant_declaration_list RIGHTPAR 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_part",33, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // component_declaration ::= error 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_declaration",32, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // component_declaration ::= discriminant_declaration NT$4 SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_declaration",32, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // NT$4 ::= 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
RESULT=d;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$4",114, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // variant_part_option ::= variant_part 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_part_option",31, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // variant_part_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_part_option",31, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // component_declaration_list ::= component_declaration_list component_declaration 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		LinkedSymbolTable t=(LinkedSymbolTable)l;
					  //the components are parserResults: en el valor viene el nombre.
					//c puede ser una lista o un solo elemento:
					if(c != null){	
					  if(!(c instanceof ArrayList)){
					 	 ParserResult p=(ParserResult)c;
						  if(!t.put(p.value, new AdaSymbol(p.type))){
							agregarError("El componente '"+((String)p.value)+
							"' ya ha sido declarado en este registro.", cleft, cright);
						  }
					  }else{//s es una lista:
						ArrayList<ParserResult> lc=(ArrayList<ParserResult>)c;
						for(ParserResult p: lc){
						  if(!t.put(p.value, new AdaSymbol(p.type))){
							agregarError("El componente '"+((String)p.value)+
							"' ya ha sido declarado en este registro.", cleft, cright);
						  }//no se pudo meter el id
							
						}//iterar en c
					  }//c es una lista
				
					}//c existe
					//subir la tabla de smbolos:
					RESULT=t;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_declaration_list",30, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // component_declaration_list ::= 
            {
              Object RESULT =null;
		RESULT=new LinkedSymbolTable();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_declaration_list",30, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // component_list ::= NULL NT$3 SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_list",29, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // NT$3 ::= 
            {
              Object RESULT =null;
RESULT=new LinkedSymbolTable();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$3",113, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // component_list ::= component_declaration_list NT$2 variant_part_option 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_list",29, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // NT$2 ::= 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
RESULT=l;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$2",112, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // record_type_definition ::= RECORD NT$0 component_list NT$1 END RECORD 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("record_type_definition",28, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // NT$1 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
RESULT=l;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$1",111, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // NT$0 ::= 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
parser.setUnclosed("end record;", "record", rleft,rright );
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$0",110, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // discrete_range ::= range 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=r;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discrete_range",27, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // discrete_range ::= numeric_type range_constraint_option 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discrete_range",27, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // discrete_range ::= name range_constraint_option 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discrete_range",27, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // fixed_point_constraint ::= DELTA simple_expression range_constraint_option 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("fixed_point_constraint",26, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // range_constraint_option ::= range_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("range_constraint_option",25, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // range_constraint_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("range_constraint_option",25, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // floating_point_constraint ::= DIGITS simple_expression range_constraint_option 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("floating_point_constraint",24, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // accuracy_constraint ::= fixed_point_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("accuracy_constraint",23, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // accuracy_constraint ::= floating_point_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("accuracy_constraint",23, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // range ::= simple_expression DOUBLEDOT simple_expression 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if ((t != null) && (f != null)){
							
					 ParserResult pr=(ParserResult)t;
					 ParserResult qr=(ParserResult)f;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							if(compare_types(ptipo,qtipo, fleft, fright)){
								ArrayList<Object> rVal=new ArrayList<Object>();
								rVal.add(pr.value);
								rVal.add(qr.value);
								RESULT=new ParserResult(rVal, ptipo);
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numrico y se encontr "+ptipo.toString(), tleft, tright);
							else 
							    agregarError("Se esperaba un tipo numrico y se encontr "+qtipo.toString(), fleft, fright);
							RESULT=null;
						}
						
					}	
					}	
		
		
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("range",22, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // range_constraint ::= RANGE range 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("range_constraint",21, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // subtype_indication_with_constraint ::= FLOAT accuracy_constraint 
            {
              Object RESULT =null;
		RESULT=new ParserResult(new FloatType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",20, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // subtype_indication_with_constraint ::= numeric_type range_constraint 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT=n;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",20, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // subtype_indication_with_constraint ::= name accuracy_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",20, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // subtype_indication_with_constraint ::= name range_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",20, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // subtype_indication ::= primitive_type 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=t;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication",19, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // subtype_indication ::= subtype_indication_with_constraint 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=c;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication",19, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // subtype_indication ::= name 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=n;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication",19, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // subtype_declaration ::= SUBTYPE identifier IS subtype_indication SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					ParserResult ps=(ParserResult)s;
					if(ps.type!= null){
					if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
						Type t=ps.type;
						t.name=(String)i;
						//se pone un nuevo tipo con otro nombre:
						if(!currentScope.put(i, new AdaSymbol(t, true))){
							agregarError("El tipo '"+((String)i)+"' ya ha sido declarado", ileft, iright);
						}
					}
					}else{
						agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
					}
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_declaration",18, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // type_definition ::= record_type_definition 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		parser.emptyLastUnclosed();RESULT=r;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("type_definition",17, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // discriminant_part_option ::= discriminant_part 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_part_option",16, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // discriminant_part_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_part_option",16, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // type_declaration ::= incomplete_type_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("type_declaration",15, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // type_declaration ::= TYPE identifier discriminant_part_option IS type_definition SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
				//viene una tabla de smbolos: porque siempre son records
				LinkedSymbolTable table=(LinkedSymbolTable)t;				
				if(!currentScope.put(i, new AdaSymbol(new RecordType(((String)i),table))))
					agregarError("El tipo '"+((String)i)+"' ya ha sido declarado", ileft, iright);
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("type_declaration",15, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // identifier_list ::= identifier_list COMMA identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int jleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int jright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object j = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		ArrayList<String> r =new ArrayList<String>();
				  r.addAll((ArrayList<String>)i);r.add((String)j);	
				  RESULT=r;	
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("identifier_list",8, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // identifier_list ::= identifier COMMA identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int jleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int jright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object j = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		ArrayList<String>r=new ArrayList<String>();
				  r.add((String)i); r.add((String)j);
				  RESULT=r;		
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("identifier_list",8, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // number_declaration ::= identifier_list COLON CONSTANT ASSIGNMENT expression SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		if(o != null){
				ParserResult po=(ParserResult)o;ArrayList<String> pi=(ArrayList<String>)i;
				for(String id:pi){
					if(!currentScope.put(id, new AdaSymbol(po.type, true)))
						agregarError("El identificador "+id+" ya ha sido declarado", ileft, iright);
				}	
				}  		
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("number_declaration",14, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // number_declaration ::= identifier COLON CONSTANT ASSIGNMENT expression SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		if(o != null){
				  ParserResult po=(ParserResult)o;
			          if(!currentScope.put(i, new AdaSymbol(po.type, true)))
					agregarError("El identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
				  }
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("number_declaration",14, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // initialization_option ::= ASSIGNMENT expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("initialization_option",13, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // initialization_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("initialization_option",13, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // object_declaration ::= identifier_list COLON constant_option subtype_indication initialization_option SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
				ParserResult ps=(ParserResult)s; 
				if (ps.type != null){
				ArrayList<String> il=(ArrayList<String>)i;
				boolean isConstant=(c != null); 
				if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
				if(o != null){				
					ParserResult po=(ParserResult)o;
					boolean compare=compare_types(ps.type, po.type, oleft, oright);
					//Type tipo=compare ? ps.type : new ErrorType(ps.type);					
					Type tipo=ps.type;
					for(String id:il){
						if(!currentScope.put(id, new AdaSymbol(tipo, isConstant)))
							agregarError("El identificador "+id+" ya ha sido declarado", ileft, iright);
					}	
				}else{//there's no initialization expression:
				   if(isConstant)
					agregarError("La declaracin de un objeto constante requiere una expresin de inicializacin", ileft, iright);	  
				   for(String id:il){
					if(!currentScope.put(id, new AdaSymbol(ps.type)))
						agregarError("El identificador "+id+" ya ha sido declarado", ileft, iright);
				   }	
				}
				}else{
					agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
	
				}
				}
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("object_declaration",12, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // object_declaration ::= identifier COLON constant_option subtype_indication initialization_option SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		ParserResult ps=(ParserResult)s; 
				//if the type is null, there was an error down the tree (and is already reported)
				if (ps.type != null){				
				boolean isConstant=(c != null); 
				if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
				if(o != null){			
					ParserResult po=(ParserResult)o;
					boolean compare=compare_types(ps.type, po.type, oleft, oright);
					//Type tipo=compare ? ps.type : new ErrorType(ps.type);					
					Type tipo=ps.type;
					if(!currentScope.put(i, new AdaSymbol(tipo, isConstant)))
						agregarError("El identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
						
				}else{//there's no initialization expression:
				   if(isConstant)
					agregarError("La declaracin de un objeto constante requiere una expresin de inicializacin", ileft, iright);					        if(!currentScope.put(i, new AdaSymbol(ps.type)))
					agregarError("El identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
				   	
				}
				}else{//s no es un subtipo de nada:
					agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);	
				}
					
				}
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("object_declaration",12, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // declaration ::= number_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // declaration ::= subtype_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // declaration ::= subprogram_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // declaration ::= type_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // declaration ::= object_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // argument ::= identifier ARROW expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("argument",10, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // argument ::= expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("argument",10, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // argument_list ::= argument_list COMMA argument 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		if(a != null){
			  ArrayList<ParserResult> r=new ArrayList<ParserResult>();
			  r.addAll((ArrayList<ParserResult>)l);
			  r.add((ParserResult)a);
			  RESULT=r;
			 }else{RESULT=l;}			
			
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("argument_list",9, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // argument_list ::= argument 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		if(a != null){
			 ArrayList<ParserResult> r=new ArrayList<ParserResult>();
			  r.add((ParserResult)a);
			  RESULT=r;
			}
			
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("argument_list",9, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // identifier ::= IDENTIFIER 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=i;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("identifier",7, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // primitive_type ::= numeric_type 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=(ParserResult)t;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primitive_type",5, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // primitive_type ::= BOOLEAN 
            {
              Object RESULT =null;
		RESULT=new ParserResult("boolean",new BooleanType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primitive_type",5, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // numeric_type ::= FLOAT 
            {
              Object RESULT =null;
		RESULT=new ParserResult("float", new FloatType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("numeric_type",6, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // numeric_type ::= INTEGER 
            {
              Object RESULT =null;
		RESULT=new ParserResult("integer", new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("numeric_type",6, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // n ::= 
            {
              Object RESULT =null;
		BackPatchResult br= new BackPatchResult(new ListaSalto(cuadruplos.size()));
			gen("goto", " ", "", "");
			RESULT=new ParserResult(br);
		      
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("n",3, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // m ::= 
            {
              Object RESULT =null;
		RESULT=new ParserResult(new Integer(cuadruplos.size()));
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("m",2, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // placeholder ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("placeholder",1, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // goal ::= compilation 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("goal",0, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // constant_option ::= CONSTANT 
            {
              Object RESULT =null;
		RESULT=true;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("constant_option",4, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // constant_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("constant_option",4, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= goal EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT = start_val;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$semantic$parser.done_parsing();
          return CUP$semantic$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

